<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM 类加载机制和类加载器</title>
      <link href="/2022/07/28/JVM/Java%20%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2022/07/28/JVM/Java%20%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>类加载机制：JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程。</p><blockquote><p>Class文件：语言无关性和平台无关性的基石，JVM不与包括Java语言在内的任何程序语言绑定，它只和Class文件这种特定的二进制文件格式所关联。JVM不关心Class文件的来源，各个语言都能实现自己编译器，将各种语言编译成Class文件。</p></blockquote><p>Class文件不仅仅可以是具体的磁盘文件，而是一串特定格式的二进制字节流，包括但不限于磁盘文件、网络、数据库、内存或动态产生。</p><p>类加载的过程分为以下阶段</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></p><p>其中，除了解析阶段可以在初始化之后开始，其余的都需要按照顺序来开始。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>Java虚拟机规范只规定了在哪些场景下必须立即对类进行初始化。</p><p>以下场景都有一个前提：只有类没有被初始化才会触发类的初始化</p><ol><li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，能够生成这些指令的典型Java代码有：</p><ul><li><p>new关键字；</p></li><li><p>读取或设置static字段（不是static final字段）；</p></li><li><p>调用一个类型的static方法；</p></li></ul></li><li><p>使用reflect包进行反射调用时；</p></li><li><p>初始化类时需要先初始化父类；</p></li><li><p>虚拟机启动时，需要初始化包含main方法的那个类；</p></li><li><p>当一个接口实现了default关键字时，如果有该接口的实现类触发了初始化，那么该接口会先初始化；</p></li><li><p>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p></li></ol><p>除了以上六种情况，其余情况均不会触发类的初始化，如：</p><ul><li><p>通过子类引用父类的静态变量；</p></li><li><p>引用一个类的常量；</p></li><li><p>通过数组引用一个类，不会触发该类的初始化；</p></li><li><p>初始化一个接口时，不会触发父接口；</p><p>…..</p></li></ul><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>将JVM外部的二进制字节流按照虚拟机所设定的格式存储在方法区之中，并在内存生成对应的Class对象作为访问入口。</p><p>JVM主要做三件事：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流；包括但不限于从ZIP压缩包中读取；从网络中获取；运行时计算生成（动态代理技术）；从数据库中读取；从加密文件中获取……</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</p></li><li><p>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口；</p></li></ol><p>加载动作需要类加载器来帮忙实现，关于类加载器，稍后还会详细讲解。</p><p>另外，对于数组类型（这里说的就是”数组“这个类型，而非具体数组类里的元素类型）来说，情况稍有不同。数组类本身不通过加载器创建，它是由JVM直接在内存中动态构造出来的。数组类型加载的规则如下：</p><ul><li><p>如果数组类型的组件类型（指数组去掉一个维度的类型）是引用类型，那么会递归（主要针对多维数组）的进行数组类型的加载，并将数组C表示在加载该组件类型的类加载器的类名称空间下；</p></li><li><p>如果数组类型不是引用类型，JVM会把数组C标记为与引导类型加载器关联；</p></li><li><p>数组类的可访问性和数组类型的可访问性一致，如果类型不是引用类型，默认为public。</p></li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>保证Class文件中的字节流包含的信息符合Java虚拟机规范的约束，保证这些信息被当作代码后不会危害虚拟机自身的安全。</p><p>尽管Java对源代码进行编译限制，但是由于Class文件的来源不确定，所以需要加上验证的阶段。</p><p>验证大致上会分成下面四个阶段的动作：</p><ol><li><p>文件格式验证：验证字节流是否符合Class文件格式的规范，保证输入的字节流能正确地解析并存储于方法区内，如版本号是否被JVM接受。经过这个阶段之后，接下来所有的信息都会从方法区获取；</p></li><li><p>元数据验证：对字节码描述地信息进行语义分析，保证描述的信息符合Java语言规范，如这个类是否有父类；</p></li><li><p>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的，如保证任何跳转指令不会跳转到方法体之外的字节码指令上；</p></li><li><p>符号引用验证：对类自身意外的各类信息进行匹配性校验，如在符号引用中通过字符串描述的全限定名是否能找到对应的类。</p></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类中定义的静态变量分配内存并设置类变量初始值。</p><p>对只有static的字段生成的是对应的零值；对static + final修饰的字段生成的是对应设置的值。</p><p>注意java虚拟机规范和具体虚拟机实现的区别：java虚拟机规范仅仅要求将静态变量存放至方法区中，而在jdk8之后的HotSpot虚拟机中，这些变量都会随着Class对象一起存放在堆区中。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>Java虚拟机将常量池的符号引用替换为直接引用的过程。</p><p>符号引用：符号引用以一组符号来描述所引用的目标，可以是任何形式的字面量（如，一个类中的静态变量，可以是类的全限定名+字段名组合而成的字面量）。</p><p>直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能够简介定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类构造器<clinit>()方法的过程。</p><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，只能赋值不能访问。</p><p>该方法不会显式的调用父类构造器，JVM会保证该方法执行之前，父类的<clinit>()方法已经执行完毕。如果一个类中没有静态语句块，也没有对静态变量的赋值，那么编译器可以不生成该方法。另外，接口中对变量的赋值也会让编译器为接口生成该方法，但是不会保证父类接口的<clinit>()方法执行（详情可以参考类加载的时机）。</p><p>另外，该方法在多线程的情况需要保证只有一个线程执行该方法。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器：在类加载的过程中，需要通过一个类的全限定名来获取描述该类的二进制字节流，实现这个功能的代码被称为类加载器。</p><h2 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确定其在JVM中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，判断一个类是否相等，只能在同一个类加载的前提下，比较才是有意义的。</p><h2 id="类加载器模型"><a href="#类加载器模型" class="headerlink" title="类加载器模型"></a>类加载器模型</h2><h3 id="三层类加载器"><a href="#三层类加载器" class="headerlink" title="三层类加载器"></a>三层类加载器</h3><p>在jdk8及之前版本的java引用，绝大多数程序都会使用到以下3个系统提供的类加载器来进行加载</p><ul><li><p>启动类加载 Bootstrap ClassLoader：负责加载存在<JAVA_HOME>\lib目录及被-Xbootclasspath参数指定的目录，并且JVM能够识别的类。如果需要把加载请求委派给启动类加载器去处理，直接使用null代替即可。</p></li><li><p>扩展类加载器 Extension ClassLoader：负责加载<JAVA_HOME>\lib\ext目录或者被java.ext.dirs系统变量所指定的路径中所有类库的类。</p></li><li><p>应用程序类加载器 Application ClassLoader：负责加载用户类路径（classpath）下所有的类库中的类。</p></li></ul><p>3个类加载器关系如图：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B1%82%E6%AC%A1.png"></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>指的是一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载去完成，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会去尝试自己去完成加载。</p><p>优点是Java中的类随着它的类加载器一起具备了一种带有优先级的层次管理。如类java.lang.Object，无论哪个类加载器要加载这个类，最终都会由bootstrap ClassLoader类加载器去完成加载。反之，如果没有使用双亲委派模型，用户自己编写了一个名为java.lang.Object类，并放在 ClassPath中，那系统中就会出现多个不同的Object类。如果尝试的话，会发现这个类无法被加载运行。</p><p>核心代码如下：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%A3%E7%A0%81.png"></p><h4 id="双亲委派模型的破坏"><a href="#双亲委派模型的破坏" class="headerlink" title="双亲委派模型的破坏"></a>双亲委派模型的破坏</h4><ul><li><p>在jdk1.2双亲委派模型出现之前；</p></li><li><p>自身缺点，比如基础类型要调用用户的代码，如JNDI、JDBC等等。以JNDI为例，JNDI是java的一个标准服务，但是在工作的时候需要调用ClassPath下的JNDI服务提供者接口的代码，此时启动类加载器肯定是不认识ClassPath下的实现类的。为了解决这个问题，java引入了线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过Thread::setContextClassLoader方法进行设置该线程的上下文类加载器，如果创建线程时未设置，它将从父线程中继承一个，如果全局都没有这是，这个类加载器默认就是应用程序类加载器了。有了线程上下文类加载器，JNDI服务使用这个线程上下文类加载器加载所需的SPI服务代码。</p></li><li><p>java语言对程序的动态性支持。</p></li></ul><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="类加载的过程有哪些？"><a href="#类加载的过程有哪些？" class="headerlink" title="类加载的过程有哪些？"></a>类加载的过程有哪些？</h2><blockquote><p>答：类加载的过程可以分为加载、连接、初始化，其中连接阶段又可以分为验证、准备、解析。</p><p>加载阶段主要是将一个静态的二进制文件流按照虚拟机规范存储在方法区内，并在堆中生成一个对应的Class对象作为访问入口。</p><p>验证阶段主要是验证Class文件的字节流是否符合java虚拟机规范的约束，保证这些信息不会危害虚拟机自身的安全。该阶段大致上会完成四个阶段的校验：</p><ol><li><p>文件格式校验；</p></li><li><p>元数据校验；</p></li><li><p>字节码校验；</p></li><li><p>符号引用校验；</p></li></ol><p>准备阶段主要是为类变量分配内存并设置初始化值，其中static类变量会分配对应的零值，static final 变量会直接分配定义好的值。</p><p>解析阶段主要是将符号引用转化为直接引用。</p><p>初始化阶段主要是执行类构造器（主要是类构造器，而不是构造函数）<clinit>()方法，该方法是编译器自动生成的。</p></blockquote><h2 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h2><blockquote><p>答：双亲委派模型是类加载时的一种机制。具体指的是当一个类加载收到类加载的请求时，会优先让父类加载器区加载这个类。</p><p>java中类加载器是有结构层次的，由上至下可以分为：</p><ol><li><p>启动类加载器，主要加载<JAVA_HOME>\lib下的类；</p></li><li><p>扩展类加载器，主要加载<JAVA_HOME>\lib\ext下的类；</p></li><li><p>应用程序类加载，主要加载Java应用下的ClassPath路径的类；</p></li></ol><p>双亲委派模型是java设计者推荐给开发者的一种类加载器实现的机制。它能够保证类可以拥有和类加载器类似的层次结构，比如Object类，无论是哪个类想要加载该类，双亲委派模型都保证了这个类必须是由启动类加载器加载的，从而保证了java程序稳定。</p></blockquote><h2 id="什么是线程上下文类加载器？它有什么用？"><a href="#什么是线程上下文类加载器？它有什么用？" class="headerlink" title="什么是线程上下文类加载器？它有什么用？"></a>什么是线程上下文类加载器？它有什么用？</h2><blockquote><p>答：java设计者推荐开发者去使用双亲委派模型实现类加载动作。但是该模型是有一定缺陷的，比如有以下场景：</p><p>java定义了一套访问的标准接口JDBC，需要调用由各个厂商实现并部署在ClassPath下的JDBC服务提供者接口。JDBC这种通用的设计肯定是比较基础的服务，需要由启动类加载器去加载该类，但是启动类加载器加载不了ClassPath下的各个实现类。所以java引入了线程上下文类加载器，在JDBC中代码中，可以拿到这个线程上下文加载器去加载所需要的JDBC实现类，从而代替默认由加载当前类的类加载器也就是启动类加载器加载JDBC实现类的这种行为。</p><p>这个类加载器可以通过Thread::setContextClassLoader方法进行设置，如果创建线程的时候没有设置，那么线程会从父线程继承一个，如果整个应用都没设置的话，默认就是应用程序类加载器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 垃圾收集器</title>
      <link href="/2022/07/26/JVM/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2022/07/26/JVM/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><p>”经典“是相对于jdk 11之后出现的低延迟垃圾收集器而言的，这些成熟的垃圾收集器仍然是 jdk8 之前重要的选择。在 G1 收集器出现之前，大多数垃圾收集器都采用分代思想，将java堆内存至少分为新生代和老年代，并且不同区域之间由于对象存活特性的不同，各个垃圾收集器针对的区域、选择的算法都有差异。</p><p>各个垃圾收集器之前能够组合的关系如下图，只有用线连起来的垃圾收集器才能够混合使用。其中CMS和Serial Old的连线是代表当CMS收集器发生失败的情况时，Serial Old将作为后备垃圾收集器。</p><p>其中 Serial、ParNew、CMS三种垃圾收集器使用HotSpot提供的分代框架，而其余垃圾收集器是自己额外实现的。所以CMS只能搭配Serial或者ParNew使用。</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%80%BB%E8%A7%88.png"></p><h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>采用复制算法，在垃圾收集时必须暂停其余所有线程，并且垃圾收集工作线程是单线程的。该收集器优点是：简单而高效，消耗额外内存最少。</p><p>仍然适合客户端模式下的java程序。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>是 Serial 收集器的多线程版本，这里说的多线程，是在垃圾收集时的工作线程可以多线程并行工作。</p><p>采用复制算法，在垃圾收集时必须暂停其余所有线程。由于很多服务端模式下java应用在老年代使用了CMS收集器，所以该收集器是很多服务端模式下java应用采用的收集器。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>采用复制算法，其余的和ParNew收集器差不多。但是前面两种收集器不同，Parallel Scavenge收集器主要关注的是吞吐量，主要适合在后台运算而不需要太多的交互的分析任务。</p><p>该收集器也被称为”吞吐量优先收集器“，该收集器还提供了垃圾收集的自适应调节策略，只要开启了开关-XX：+UseAdaptiveSizePolicy，就不需要人工指定新生代大小、Eden和Servivor比例等细节参数，而是JVM会根据当前系统的运行情况，动态的设置这些参数达到一个比较好的吞吐量或者停顿时间。</p><h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><p>需要说明的是，以下三种收集器虽然理论上是仅针对老年代的收集器，但是只有CMS中才会有”仅针对老年代（称为Old GC或Major GC）“的收集，其余两种在进行老年代收集时同时会触发新生代收集（称为 Full GC）。所以，也只有CMS需要考虑老年代收集时，新生代的对象持有了老年代的对象这种跨代引用的情况，在这种情况下，需要将整个新生代作为GC Roots来进行扫描。</p><blockquote><p>老年代对象持有新生代对象引用的解决办法是引入记忆集和卡表的方法解决的。</p></blockquote><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>采用标记整理算法，是Serial收集器的老年代版本。在垃圾收集时也是需要暂停用户线程，主要用于客户端模式下的java应用，或者服务端下的java应用作为cms收集器的预备方案。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>采用标记整理算法，时Parallel Scavenge收集器的老年代版本，是JDK 6之后才提供的，至此，如果是关注吞吐量的任务，可以采用 Parallel Scavenge + Parallel Old 收集器，这也是JDK 9之前的默认选择。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>采用标记-清除算法。CMS收集器主要关注的是停顿时长，适合基于浏览器的B&#x2F;S系统或者互联网网站。</p><p>主要分为四个步骤：</p><ol><li><p>初始标记：需要暂停用户线程，仅仅标记GC Roots能直接关联到的对象，速度很快；</p></li><li><p>并发标记：不需要暂停用户线程，遍历整个对象图，耗时较长；</p></li><li><p>重新标记：需要暂停用户线程，主要通过增量更新的方式标记第2步改动的对象；</p></li><li><p>并发清除：不需要暂停用户线程，清理掉已经被标记为垃圾的对象。</p></li></ol><p>总的来说，垃圾收集中最耗时的第二步和第四步是可以和用户线程并发进行，所以整体的暂停时长会比较短。工作的流程如图：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/CMS.png"></p><p>缺点：</p><ol><li><p>需要占用一部分线程，导致程序的总吞吐量下降；</p></li><li><p>无法处理浮动垃圾，只能留在下一次垃圾收集清理；而且在并发清除的过程中，用户线程还在持续运行，JVM不得不留有一部分内存以供用户分配。问题在于，如果留有内存较大，那么GC的频率就会相应变高；如果留有内存较小，那么可能会导致用户线程无法分配到足够的内存导致启动预备方案：暂停所有用户线程，临时启动Serial Old收集器进行垃圾收集。</p></li><li><p>会有内存碎片产生；解决的方法时，如果不得不进行内存整理了，那么会暂停用线程来整理内存碎片，这样就会导致停顿时间的增加。</p></li></ol><h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><p>G1 收集器整体上采用的是标记-整理算法，局部采用的复制算法。</p><p>是JDK第一款出现的跨代收集器，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1 收集器的期望是，在停顿时间可控的前提下，去追求更高的吞吐量。相比于CMS，G1做出的重要思想转变就是将GC这种”大成本“的操作改为单次成本更小的操作。在G1之前，所有的垃圾收集器都是回收整个区域（新生代或者老年代或者整堆），而G1则是将整个堆划分为多个小区域，GC时，根据具体的选择算法，选择出回收收益最大的区域。虽然G1总体上仍然是基于分代的思想，但是单次回收的衡量标准不再是它属于哪个分代，而是基于收益的来确定回收的区域，这种模式被称为Mixed GC模式。</p><blockquote><p>选择算法更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，优先处理回收收益最大的Region。</p></blockquote><p>G1 Region布局：把连续的Java堆划分为多个大小相等的的独立区域（Region），每一个Region根据需要都可以扮演新生代的Eden，Survivor或者老年代空间；针对于大对象，会根据对象的大小有两种处理方式：</p><ul><li><p>如果对象大于整个Region的一半，那么会采用Humongous Region区域来存放；</p></li><li><p>如果对象大于整个Region，那么会采用多个连续的Humongous Region区域来存放。</p></li></ul><p>Humongous Region区域被看做是老年代的一部分。</p><p>G1的复杂之处：</p><ol><li><p>将Java堆中分成多个独立的Region之后，跨代引用如何解决？</p><p>思路仍然是通过记忆集和卡表的方式避免全堆作为GC Roots扫描，只是由于G1中的Region区域很多，需要单独为每一个Region建立卡表，并且卡表数据结构需要保存引用该Region的其余Region的地址。在Shenandoah中，采用了连接矩阵来实现此功能。</p><p>由于Region的数量明显会比分代的数量多得多，所以需要更大的额外内存来做这些工作，根据经验，G1额外内存会占据整堆的10%~20%。</p></li><li><p>如何在并发标记阶段保证收集线程和用户线程互不干扰？</p><p>和CMS不同，该过程产生的新的引用对象是通过原始快照（STAB）解决的。此外在每一个Region上，G1分配了两个名为TAMS（Top at Mark Start）指针，并发回收时分配新内存必须要在这两个指针的区域之间，这块区域里的对象会在当次GC中默认是存活的对象。另外，和CMS类似，如果内存回收速率赶不上内存分配速率，最终仍然会导致Full GC。</p></li><li><p>如何建立可预测的停顿时间模型？</p><p>G1收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。筛选均值和均值相比就是更加注重”最近“的情况。</p></li></ol><p>G1收集器大致分为四个步骤：</p><ol><li><p>初始标记：需要暂停用户线程，标记一下GC Roots能直接关联的对象，并且修改TAMS指针的值；</p></li><li><p>并发标记：不需要暂停用户线程，遍历整个对象图，耗时较长；</p></li><li><p>最终标记：需要暂停用户线程，标记第2步产生的新的对象应用关系，采用的方式为原始快照，速度很快；</p></li><li><p>筛选回收：需要暂停用户线程，筛选出价值最高的Region区域，并将这些Region里的对象移动至新的Region中，由于G1收集器并需要将所有Region区域的垃圾都进行清除，所以该阶段的耗时较短并可控。暂停用户线程进行还可以获得较大的吞吐量。</p></li></ol><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/G1.png"></p><p>G1相比于CMS的优点：</p><ol><li><p>没有内存碎片；</p></li><li><p>可以指定最大停顿时间；</p></li></ol><p>G1相比于CMS的缺点：</p><ol><li><p>占用内存过高，主要体现在每个Region都需要维护一份卡表；</p></li><li><p>占用CPU过高，主要体现在原始快照和增量更新这两种算法上。</p><blockquote><p>CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索 （SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。</p></blockquote></li></ol><h1 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h1><p>衡量垃圾收集器的最重要的指标：</p><ul><li><p>内存占用；</p></li><li><p>吞吐量；</p></li><li><p>延迟；</p></li></ul><p>这三者有人证明了不可能同时具有完美的表现，通常只能同时达成两项。其中延迟是目前我们主要关心的地方，而CMS和G1在这方面也并不是完美的，而且随着堆容量的扩展，这两款收集器的延迟时间也会随之变长。</p><p>CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何优  化改进，在设计原理上避免不了空间碎片的产生，随着空间碎片不断淤积最终依然逃不过“Stop The  World”的命运。G1虽然可以按更小的粒度进行回收，从而抑制整理阶段出现时间过长的停顿，但毕竟也还是要暂停的。</p><p>在两款低延迟垃圾收集器中，ZGC的单次停顿更短，通常在10ms以下；而Shenandoah收集器的吞吐量相对更高一些。</p><h2 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h2><p>shenandoah 收集器可以看作是G1收集器的升级版。有很多和G1类似的地方，最主要的地方如下：</p><ol><li><p>支持并发的整理。这点是和其余的收集器最核心的差别。如果能够暂停用户线程，那么整理是比较简单的，如果需要和用户线程并发执行，那么必须要考虑移动过程中，对象的移动和所有引用该对象的引用地址更改需要同时进行。shenandoah是采用Brooks Pointer指针实现的。</p></li><li><p>不使用分代收集；</p></li><li><p>记忆集变成了连接矩阵，降低了记忆集的开销，也降低了发生伪共享的概率。</p></li></ol><p>核心流程的如下：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/Shenandoah.png"></p><p>其中，蓝色的区域代表的是被选入回收集的Region，绿色部分就代表还存活的对象，蓝色就是用户线程可以用来分配对象的内存Region。主要分为三大部分：</p><ol><li><p>并发标记；</p></li><li><p>并发回收；</p></li><li><p>并发引用更新。</p></li></ol><p>其中，并发回收和并发引用更新都需要依赖Brooks Pointer（转发指针）。Brooks Pointer的示意图如下：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/BrooksPoint.png"></p><p>转发指针带来的好处就是，当对象拥有一份新的副本，只需要修改一处指针的值。但是修改的时候必须考虑并发问题，实际上是通过CAS的方式实现的。</p><p>另外，转发指针带来了缺点：</p><ol><li><p>访问对象多了一次开销；</p></li><li><p>访问对象的频率是十分高频的，Shenandoah收集器是通过读屏障实现的，因此读屏障需要特别注意性能问题，风险很高。</p></li></ol><h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>ZGC的内存布局其实和G1以及Shenandoah差不多，只不过它的Region分为三种：</p><ol><li><p>小型Region：固定为2MB，用于放置小于256KB的对象；</p></li><li><p>中型Region：固定为32MB，用户放置大于等于256KB但是小于4MB的对象；</p></li><li><p>大型Region：容量不固定，必须是2MB的整数倍。</p></li></ol><p>ZGC最核心的差异点仍然是整理阶段，在ZGC中，是采用的染色指针的技术来实现的。</p><p>考虑以下场景：判断一个对象是否是垃圾，其实只需要关心这个对象的引用，而不必关心这个对象本身，所以实现对象的标记有不同的实现方式：</p><ul><li><p>直接记录在对象头上，如Serial收集器；</p></li><li><p>单独维护一个结构，如G1、Shenandoah；</p></li><li><p>直接把标记信息记在引用对象的指针上。</p></li></ul><p>染色指针通过将指针的前4为作为标记位加上多重映射（为了保证操作系统能够正常支持寻址）来实现这个方式。</p><p>通过染色指针主要可以直接确认以下三个点：</p><ol><li><p>引用对象的三色标记状态；</p></li><li><p>是否进入了重分配集；</p></li><li><p>是否只能通过finalize()方法才能被访问到；</p></li></ol><p>染色指针有以下优势：</p><ol><li><p>可以确保某个Region的存活对象被移走之后，这个Region能够立刻被清理，而不用等待所有指向这个Region的所有引用都被修正之后；</p></li><li><p>可以大幅减少内存屏障；</p></li><li><p>可扩展；</p></li></ol><p>ZGC的工作流程：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/ZGC.png"></p><p>其中和其余收集器有着关键差别的有：</p><ul><li><p>并发标记：标记不是在对象上，而是在指针上；</p></li><li><p>并发预备重分配：统计本次收集要清理哪些Region，组成重分配集；</p></li><li><p>并发重分配：该阶段是核心阶段，需要将重分配集中的对象复制到新的Region上，并为重分配集中的每一个Region维护一个转发表。当有线程同时访问重分配集的对象时，这次访问将会被预置的内存屏障捕获，会将访问转发到新复制的对象上，并且更新引用的值，这个过程称为”自愈“；</p></li><li><p>并发重映射：类似Shenandoah的并发引用更新，只不过ZGC由于有自愈的存在，该动作并不紧急，所以会选择在下一次GC的并发标记阶段执行。</p></li></ul><p>ZGC的缺点：</p><ol><li>能够承受的对象分配速率不高，因为ZGC中没有分代的概念，所以每次垃圾收集都是针对全堆的，即使停顿时间叫短，但是整个流程会比较长。如果分配速率很高，那么在本次垃圾收集历程还没有结束就会有大量的对象被新分配，久而久之触发Full GC。</li></ol><p>ZGC的额外优点：</p><ol><li><p>支持”NUMA-Aware“内存分配。</p><blockquote><p>NUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种为多处理器或者多核处理器的计算机所设计的内存架构。由于摩尔定律逐渐失效，现代处理器因频率发展受限转而向多核方向发展，以前原本在北桥芯片中的内存控制器也被集成到了处理器内核中，这样每个处理器核心所在的裸晶（DIE）[12]都有属于自己内存管理器所管理的内存，如果要访问被其他处理器核心管理的内存，就必须通过Inter-Connect通道来完成，这要比访问处理器的本地内存慢得多。在NUMA架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p></blockquote></li></ol><h1 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h1><p>考虑以下几点：</p><ul><li><p>应用的关注点是什么？如吞吐量还是延迟；</p></li><li><p>应用运行的基础设施是什么？如硬件规格和操作系统架构；</p></li><li><p>JDK发行商和版本；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 引用类型</title>
      <link href="/2022/07/25/JVM/Java%20%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/07/25/JVM/Java%20%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java 为了更好的描述“引用”和对象的关系，在jdk1.2时期，对引用的概念进行了扩充，分为强引用、软引用、弱引用、虚引用四种</p><h1 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h1><p>强引用是最传统的引用定义，是指在程序代码中普遍存在的引用赋值。例如“Object obj &#x3D; new Object()” 这种，如果一个引用为强引用，那么JVM宁愿抛出OOM异常，也不会对该引用的对象进行垃圾回收。</p><h1 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h1><p>软引用是用来描述一些还有用，但是非必须的对象。系统如果内存足够，那么垃圾回收不会清理这些对象，只有即将抛出OOM异常的时候，才会将这些对象进行二次回收来释放更多的空间。jdk1.2 使用 SoftReference 类来实现软引用。</p><h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p>弱引用和软引用的功能类似，但是它的强度比软引用更弱一下，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。jdk1.2提供了 WeakReference 类实现弱引用。</p><h1 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h1><p>虚引用也被成为“幻影引用”或者“幽灵引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2版之后提供了 PhantomReference 类来实现虚引用。</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Java-引用类型有哪些？"><a href="#Java-引用类型有哪些？" class="headerlink" title="Java 引用类型有哪些？"></a>Java 引用类型有哪些？</h2><blockquote><p>答：Java 引用类型是jdk1.2版本提出的概念，在此之前的 Java 引用类型就是传统意义上的指针概念。而 Java 为了能够更好的描述对象，如希望某些对象内存充足的时候能够保留在内存中，内存不足的时候进行垃圾回收，对引用的概念进行了扩充。</p><p>引用分为强引用、软引用、弱引用、虚引用，这4种引用的强度逐渐降低。</p><p>强引用就是传统的引用定义，如 Object obj &#x3D; new Object() 这段代码的 obj 就是一个强引用，JVM 在任何时候都不会对强引用引用的对象进行垃圾回收，即使抛出OOM异常也不会；</p><p>软引用的强度比强引用弱一些，主要体现在JVM会在内存不足也就是即将抛出OOM的时候对这些引用的对象进行垃圾回收，可以使用 SoftReference 来实现软引用；</p><p>弱引用的强度比软引用更弱一些，主要体现JVM在每次垃圾回收时，都会对弱引用引用的对象进行垃圾回收，可以使用 WeakReference 来实现弱引用；</p><p>虚引用是最弱的引用类型，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。可以使用 PhantomReference 类来实现虚引用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java finalize</title>
      <link href="/2022/07/25/JVM/finalize()%20%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/25/JVM/finalize()%20%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h1><p>finalize() 方法并不完全等同于C、C++中的析构函数，而仅仅是Java刚诞生时让C、C++程序员更容易接受Java所做出的一种妥协。</p><p>它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已经被官方明确标记为不推荐的语法。在实际生产工作最好不要用到。</p><h2 id="垃圾回收中的finalize"><a href="#垃圾回收中的finalize" class="headerlink" title="垃圾回收中的finalize()"></a>垃圾回收中的finalize()</h2><p>在垃圾回收中的可达性分析算法中，会给标记为“垃圾”的对象进行再一次的筛选：在这些“垃圾”对象中会筛选出满足条件的对象。筛选需要同时满足以下两个条件：</p><ol><li><p>finalize() 方法未被JVM调用过；</p></li><li><p>对象覆盖了finalize()方法；</p></li></ol><p>如果该对象同时满足以上两个条件，那么JVM会将该对象放置到一个名为F-Queue的队列之中，并在稍后由一条JVM自动建立的优先级较低的Finalizer线程去执行它们的 finalize() 方法。如果该对象在 finalize() 方法中重新将对象和一个GC Roots 引用链关联起来，那么该对象就可以“逃脱”此次垃圾收集。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 偏门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 垃圾收集</title>
      <link href="/2022/07/25/JVM/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
      <url>/2022/07/25/JVM/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>垃圾收集需要解决三件事情</p><ol><li><p>哪些内存需要回收？</p></li><li><p>什么时候回收？</p></li><li><p>如何回收？</p></li></ol><h1 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h1><p>主要解决 “哪些内存需要回收” 问题，主流的算法有两种，分别为引用计数法和可达性分析算法。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>基本思路：在对象中添加一个引用计数器，每当有一个地方引用该对象时，计数器值加一；引用失效时，计数器值减一；任何时刻计数器为0的对象就是不能再被使用的。</p><p>优点：原理简单，判定效率高；</p><p>缺点：占用额外的内存空间；最致命的缺点是，很难解决类似多个对象循环引用的场景。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>基本思路：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。</p><p>固定可以作为GC Roots的对象，主要在全局性的引用和执行上下文：</p><ul><li><p>全局性引用：</p><ul><li><p>方法区中常量引用的对象；</p></li><li><p>方法区中静态属性引用的对象；</p></li><li><p>Java 虚拟机内部的引用，如基本类型对应的Class对象，常驻的异常对象，系统类加载器。</p></li></ul></li><li><p>执行上下文：</p><ul><li><p>Java 虚拟机栈中引用的对象，比如参数、局部变量、临时变量等等；</p></li><li><p>本地方法栈中引用的对象；</p></li><li><p>持有同步锁（Synchronized关键字）的对象；</p></li></ul></li></ul><p>除了固定的GC Roots之外，各个垃圾收集器会根据当前回收的区域不同，可能会将其他对象临时性的加入。最典型的是局部回收，比如新生代回收时需要考虑老年代持有新生代对象的引入。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>分代收集理论是一套符合大多数程序运行实际情况的经验法则。它包含两个内容：</p><ol><li><p>弱分代假说：绝大多数对象都是朝生夕灭的。</p></li><li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p></li></ol><p>从上面两个假说可以推出第三个经验法则：</p><ol start="3"><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>这两个分代假说共同奠定了多款常用的垃圾收集器一致的设计原则：收集器应当将Java堆划分出不同的区域。然后将回收对象依据年龄分配到不同的区域。在Java堆划分出不同的区域之后，垃圾收集器才可以只回收其中某些部分的区域；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。</p><p>针对于具体的商用JVM，设计者一般至少会把Java堆划分为新生代和老年代两个区域。</p><p>通常能够单独发生垃圾收集的仅仅是新生代，实际上除了CMS收集器，其余收集器都不存在只针对老年代的收集。</p><p>GC术语说明：</p><ul><li><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</p><ul><li><p>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新年代的收集；</p></li><li><p>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的收集，目前只有CMS收集器会有这种行为。</p></li></ul></li><li><p>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</p></li><li><p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p></li></ul><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成之后，统一回收掉所有被标记的对象。</p><p>缺点：</p><ol><li><p>执行效率不稳定，两个过程的执行效率都随对象数量的增长而增长；</p></li><li><p>会产生大量的内存碎片；</p></li></ol><h2 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h2><p>简称复制算法。将可用的内存分为两块，每次只使用其中一块，用完之后将这块内存还存活的对象复制到另外一块里面区，然后将这个内存清理掉。</p><p>缺点：</p><ol><li><p>如果多数对象是存活的，会产生大量的复制开销；</p></li><li><p>浪费内存。</p></li></ol><p>针对浪费内存这一点，可以依据分代收集里面第一条。将新生代里面的区分分为一块较大的Eden区和两块较小的Survivor区。默认大小比例为8:1:1。每次发生垃圾回收时，将Eden和正在使用的Servivor区进行垃圾回收，将仍让存活的对象复制进另外一块未使用的Servivor区。这样虽然一定程度上解决了浪费内存的问题（只浪费新生代10%，而不是50%），但是也引入了新问题：如果Survivor区已经放不下一次Minor GC存活的对象，那么就需要将这些对象直接进入老年代，这种行为称为<code>分配担保</code>。</p><h2 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2><p>该算法主要针对老年代的，主要实现为在标记完哪些对象是垃圾之后，不是直接对这些对象进行清除，而是让所有存活的对象向内存空间一端移动，避免出现内存碎片。</p><p>优点：不会出现内存碎片，在分配对象内存空间时，仅仅采用移动指针方式分配即可，非常高效；</p><p>缺点：在老年代中，存活的对象较多，移动起来的开销和风险都很大。</p><p>从垃圾收集的停顿时间来看，不移动对象停顿时间更短；从程序吞吐量来说，由于分配对象的动作频率远远高于垃圾回收的频率，所以移动对象的整体吞吐量更高。</p><p>除此之外，还有一种“中庸”的方式，那就是先采用标记清除，等内存碎片化程度已经影响到对象分配了，再采用标记整理收集一次。典型代表就是CMS收集器。</p><h2 id="HotSpot-算法细节实现"><a href="#HotSpot-算法细节实现" class="headerlink" title="HotSpot 算法细节实现"></a>HotSpot 算法细节实现</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>GC Roots 主要为全局性的引用和执行上下文，在一个Java 程序中，这些对象是很多的，并且方法区和栈中不仅仅只存放引用类型，其余如基本类型也是有可能存放的，如果遍历整个方法区和栈，无疑会带来很多开销。而且根节点枚举是必须要暂停用户线程的。</p><p>HotSpot是通过一种名为<code>OopMap</code>的结构额外保存所有的GC Roots对象的，该结构也是HotSpot实现<code>准确式GC</code>算法的。</p><blockquote><p>准确式GC：不管是根对象，还是派生对象，都标记其类型。JVM中引入外部数据结构OopMap+OopMapBlock实现了该算法。</p></blockquote><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>HotSpot在OopMap的帮助下实现了较快且准确的GC Roots枚举，但是引起GC Roots对象引用关系变更的动作非常之多，如果对每一个这样的动作都保存一份OopMap，开销无疑是巨大的。因此，HotSpot引入了安全点的概念，安全点就是HotSpot为了节省上述开销，选取的<code>特定位置</code>来记录OopMap。也就是说，用户线程只有在安全点上才能够暂停。</p><p>安全点的选取一般都是能够让程序长时间执行的指令，如方法调用、循环跳转、异常跳转等。</p><p>线程跑到最近安全点的具体实现方式有两种，现在一般都是采用主动式中断：</p><ol><li><p>抢先式中断：如果线程当前没有在安全点，那么就让线程再执行一会，直到到达安全点为止；</p></li><li><p>主动式中断：当垃圾收集需要暂停线程时，不直接对线程进行操作，而是仅仅设置一个标志位，各个线程在执行过程中会不断的轮训这个标志位，一旦这个标志位为真，那么用户线程就会在最近的安全点主动中断挂起。</p></li></ol><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点是针对于能过获取CPU的线程来说的，如果一个线程没有被分配到CPU，那么就没有继续往下执行的能力，在获取下一个CPU时间之前，是永远不可能到达安全点的。</p><p>因此，HotSpot引入安全区域的概念，安全区域可以看作是安全点的拉伸，在此区域内，GC Roots的引用关系不会发生变化，也就是说在这区域内的任意位置，都是安全的。</p><p>线程在进入安全区域的时候，会标识自己已经进入了安全区域，此时JVM如果发生垃圾收集需要暂停线程时就不用管该线程，；线程在即将退出安全区域的时候，需要检查JVM暂停用户线程的阶段是否已经过了，如果没有过，那么就不允许线程退出安全区域。</p><h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><p>记忆集主要用于解决跨代引用效率的问题。在新生代中，会通过一个记忆集的数据结果保存老年代那些引用了新生代对象的对象，在GC开始之前，会将记忆集中的所有对象就加入到GC Roots中区。</p><p>卡表是记忆集的一种实现方式，主要思想就是记忆集中不保存具体的对象，而是保存连续的一段内存，每当这段内存中有对象引用了新生代对象时，就会将其标识为脏内存。在GC时，只要筛选出卡表中变脏的元素，就可以轻易得出哪些内存区域包含跨代指针。</p><p>“变脏”这个动作是通过写屏障来实现的。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>写屏障可以看作是虚拟机层面上对”引用类型字段赋值“这个动作的AOP切面，在引用对象赋值时会产生一个通知，供程序执行额外的动作。写屏障根据赋值的时机分为写前屏障和写后屏障，大多数垃圾收集器使用的都是写后屏障。</p><p>应用写屏障之后，虚拟机就会为所有的赋值操作生成响应的指令，这也会产生额外的开销。</p><p>除了写屏障的开销，卡表在高并发场景下还面临”伪共享“问题。</p><h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>这里说的并发可达性分析，主要是在GC Roots已经扫描完成，接下来就是根据GC Roots对象继续往下遍历得到存活的对象了。和根节点枚举相比较，这一部分是耗时很长的，如果这个时间段也暂停用户线程，那么影响会非常大，这是不可以接受的。</p><p>如果在一个快照（引用关系不变）上面进行遍历，原理是十分简单的，我们引用三色标记作为工具来说明，整个堆对象可以标记成以下三种颜色的一种：</p><ul><li><p>黑色：表示对象已经被垃圾收集器访问过，并且这个对象持有的所有引用也已经遍历过了（仅仅是直接引用，引用的引用不计算）。</p></li><li><p>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过；</p></li><li><p>白色：表示对象没有被垃圾收集器访问过。</p></li></ul><p>在并发标记的过程中，由于引用关系会变，所以可能会有以下影响：</p><ol><li><p>把原本消亡的对象标记为存活，产生浮动垃圾，这个影响较小；</p></li><li><p>把原本存活的对象标记为消亡，这是不可以接受的。</p></li></ol><p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p><ol><li><p>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</p><p>可以通过增量更新来解决这个问题：如果有这种引用的插入，那么需要将此次插入涉及到的黑色对象记录下来，等整个并发标记的流程走完之后，重新遍历记录下来的黑色对象，重新标记需要暂停用户线程。（CMS采用这种）</p></li><li><p>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p><p>可以通过原始快照来解决这个问题：如果有这种引用的删除，那么需要将此次删除涉及到的灰色对象记录下来，等整个并发标记的流程走完之后，重新遍历记录下来的灰色对象，重新标记需要暂停用户线程。（G1、Shenandoah采用这种）</p></li></ol><h1 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h1><p>Java虚拟机规范中提到，虚拟机可以不实现方法区的垃圾回收，事实上也确实有某些收集器，如 jdk11 的ZGC，没有实现或者说没有完整实现方法区的垃圾回收。方法区收集收集的性价比也远远比不过堆区的垃圾收集。</p><p>方法区主要有回收两部分内容：</p><ol><li><p>废弃的常量：这部分内容和java堆区的垃圾收集非常类似；</p></li><li><p>不再使用的类型：判断一个类是否未被使用条件比较苛刻，必须满足以下条件：</p><ol><li><p>该类的所有实例均已被回收；</p></li><li><p>加载该类的类加载器已经被回收；</p></li><li><p>该对象对应的Class对象没有在任何地方被引用。</p></li></ol><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。</p></li></ol><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="在JVM垃圾收集有哪些算法？"><a href="#在JVM垃圾收集有哪些算法？" class="headerlink" title="在JVM垃圾收集有哪些算法？"></a>在JVM垃圾收集有哪些算法？</h2><blockquote><p>答：  垃圾收集算法主要有标记清除、标记复制、标记整理算法三种。</p><p>其中三种垃圾收集算法都有“标记”阶段，这个阶段主要是判断一个对象是否为“垃圾”，这个阶段又可以分为引用计数法和可达性分析算法。</p><p>三种垃圾算法中主要差异点在第二阶段，也就是真正清理垃圾的阶段。</p><p>标记清除算法直接将标记阶段标记的对象进行清理；</p><p>标记复制算法则是将整个回收区域分为两块，每次进行对象分配时只会使用其中一块，触发垃圾收集时，会将正在使用的区域内存活的对象复制到另外一块未使用的区域中，然后再将之前使用的区域全部清理掉。</p><p>标记整理算法则是标记阶段标记的对象不直接进行清理，而是让所有的对象全部移动到内存区域的一端。</p><p>三种算法各有优劣：</p><p>其中标记清除算法主要优点是具体收集的时候执行效率高，体现在单次垃圾回收的时候停顿时间短，缺点是会产生垃圾碎片，影响对象分配内存时的效率；</p><p>标记复制算法主要优点是不会产生内存碎片，而且相比于标记整理算法，效率更高（我理解标记复制算法在标记的过程中，将存活对象直接复制到另外一个区域；而标记整理算法需要标记所有对象之后，再进行统一的整理），缺点是浪费空间，并且需要额外的空间进行<code>分配担保</code>;</p><p>标记整理算法主要优点是不会产生内存碎片，主要缺点是在有大量存活对象的时候，移动对象的操作成本很高、风险很大。</p><p>之所以会有几种算法的不同，是因为目前大多数虚拟机都基于分代收集理论，根据不同区域下对象的特性来分区域进行垃圾回收的。总的来说，java堆至少分为新生代和老年代，其中新生代中绝大部分对象存活时间较短，老年代中大部分对象存活时间较长，并且对象大部分情况来说是分配至新生代的。所以新生代更适合不会产生内存碎片且清理效率较高的标记复制算法，而老年代更适合采用标记清除算法或者标记整理算法。</p><p>针对新生代的标记整理算法，并不需要完全按照1:1的空间比例来进行分割，而是根据经验值，默认分为一个较大的Eden区和两个较小的Servivor区，每次分配新对象时在Eden区分配，垃圾收集时同时将Eden和一块Servivor区的存活对象复制到另外一个Servivor区即可。</p><p>针对老年代的标记清理和标记整理算法的选择，各个垃圾收集器的选择不同，总的来说标记清理算法会使得本次垃圾收集停顿时间较短，但是会产生内存碎片，慢慢的影响到对象分配内存的效率；而使用标记整理算法会使得本次垃圾收集停顿时间相对较长，但是不会产生内存碎片，因为对象分配的频率远远高于垃圾收集的频率，所以采用标记整理算法可以使得Java程序总的吞吐量上升。另外还有一种“中庸”的选择，就是先采用标记清理算法，等内存碎片已经影响到了对象分配了，再使用标记整理算法来一次性消灭掉内存碎片。</p></blockquote><h2 id="在Java垃圾回收中，如果判定一个对象是否为”垃圾“？"><a href="#在Java垃圾回收中，如果判定一个对象是否为”垃圾“？" class="headerlink" title="在Java垃圾回收中，如果判定一个对象是否为”垃圾“？"></a>在Java垃圾回收中，如果判定一个对象是否为”垃圾“？</h2><blockquote><p>答：在垃圾回收中，如何哪种垃圾回收算法，都需要对一个对象进行”标记“，用于真正清理时的依据，主流的垃圾标记算法有两种：</p><p>引用计数法和可达性分析算法。</p><p>引用计数法的原理比较简单，就是在对象中额外开辟一小段空间，来存储该对象被引用的次数，如果该对象被引用的次数为0，那么即可认为该对象是垃圾。</p><p>可达性分析算法的基本思路，是通过一系列的”GC Roots“对象作为起点，根据引用关系向下搜索，如果某个对象在遍历完所有的GC Roots仍然搜索不到，即不可达，那么即可认为该对象是垃圾。</p><p>引用计数法的优势是原理简单、判定效率高，但是由于某些场景的存在，具体实现起来比较困难，如很难解决循环引用的问题，所以在Java 垃圾回收中，主要采用的是可达性分析算法。</p></blockquote><h2 id="哪些对象可以作为GC-Roots"><a href="#哪些对象可以作为GC-Roots" class="headerlink" title="哪些对象可以作为GC Roots?"></a>哪些对象可以作为GC Roots?</h2><blockquote><p>答：如果不考虑分代收集的影响，默认作为GC Roots 主要分为三部分：</p><p>第一种为全局性的引用，其中包括静态属性引用的对象和常量属性引用的对象；</p><p>第二种为当前执行上下文，其中包括Java虚拟机栈中引用的对象，比如方法参数、局部变量、临时变量等以及本地方法栈中引用的对象。</p><p>第三种为虚拟机内部的引用，如基本数据类型的Class对象，常驻的异常对象，系统类加载器、持有同步锁的对象等等。</p><p>而各个垃圾收集器，大多都遵行了”分代收集“的理论进行设计，在某些只针对部分区域进行垃圾收集的情况，也要考虑其余区域的对象引用了当前区域的对象的情况。针对于跨代引用的情况，垃圾收集器会在当前区域中建立记忆集的数据结构，来存放其余区域的跨代引用。记忆集是一种设计实现，目前最常见实现记忆集的方式为”卡表“的方式。</p><p>卡表最核心的思想就记忆集中存放的不是一个个具体的对象，而是一段段的内存区域，只要该区域中出现了跨代引用，那么就会把该段区域标记为脏区域。在垃圾收集中，会遍历所有脏区域，将脏区域中的对象加入GC Roots一并进行扫描。</p></blockquote><h2 id="如何将卡表中的区域标记为脏区域？"><a href="#如何将卡表中的区域标记为脏区域？" class="headerlink" title="如何将卡表中的区域标记为脏区域？"></a>如何将卡表中的区域标记为脏区域？</h2><blockquote><p>答：主要是通过写屏障实现的。</p><p>写屏障可以看作是虚拟机层面上对”引用类型字段赋值“这个动作的AOP切面，在引用对象赋值时会产生一个通知，供程序执行额外的动作。写屏障根据赋值的时机分为写前屏障和写后屏障，大多数垃圾收集器使用的都是写后屏障。</p><p>应用写屏障之后，虚拟机就会为所有的赋值操作生成响应的指令，这也会产生额外的开销。</p><p>除了写屏障的开销，卡表在高并发场景下还面临”伪共享“问题。</p></blockquote><h2 id="在可达性分析算法中，没有在引用链上的对象一定会被垃圾回收吗？"><a href="#在可达性分析算法中，没有在引用链上的对象一定会被垃圾回收吗？" class="headerlink" title="在可达性分析算法中，没有在引用链上的对象一定会被垃圾回收吗？"></a>在可达性分析算法中，没有在引用链上的对象一定会被垃圾回收吗？</h2><blockquote><p>答：不一定。</p><p>在垃圾回收算法中，一个对象被标记为“垃圾”，至少得需要经历两次标记。</p><p>第一次标记就是我们常说的可达性分析算法中的标记。</p><p>第二次标记针对的对象是第一次已经被标记的对象，JVM会对这些对象再次进行筛选，如果这些对象同时满足两个条件：</p><ol><li><p>对象覆盖了 finalize() 方法；</p></li><li><p>JVM没有执行过该对象的 finalize() 方法；</p></li></ol><p>那么，JVM就会在真正回收该对象之前的某个时间执行该对象的 finalize() 方法，如果对象的 finalize() 方法重新将自己与引用链上的某个对象建立了关联，那么JVM就不会将该对象进行垃圾回收。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot 对象</title>
      <link href="/2022/07/24/JVM/HotSpot%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/07/24/JVM/HotSpot%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>本章节涉及到的对象均是在 HotSpot 虚拟机的 Java 堆中。 </p><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>两种创建方式：</p><ol><li><p>如果内存布局是整齐的，那么只需要在以分配和未分配的内存分割点加一个指针，分配内存仅仅只需要将该指针往后移动需要分配对象的大小的位置即可。这种方式被称之为 <code>指针碰撞</code>；</p></li><li><p>如何内存布局是不整齐的，那么 JVM 必须维护一个列表，用来记录哪些内存块是可用。的，分配内存时，需要从列表中找到对应的内存块来分配。这种方式被称之为 <code>空闲列表</code>。</p></li></ol><p>内存布局是否整齐是由各个垃圾收集器采用的垃圾收集算法决定的。不过即使内存布局是不整齐的，也是可以通过预先分配一大块空闲内存块，然后在这块区域采用 <code>指针碰撞</code> 方式分配内存。</p><p>对象的内存分配在堆上，那么必然要考虑并发问题。两种方式解决：</p><ol><li><p>采用CAS+失败重拾来保证更新操作的原子性；</p></li><li><p>按照线程来分隔不同的空间，每个空间变成线程私有的，即每个线程在堆中预先分配一小块内存，这块内存称为 <code>本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）</code>，该选项可以通过 <code>-XX:+/-UseTLAB</code> 来设定。</p></li></ol><p>内存分配完之后，JVM需要堆对象头进行不要的设置，再之后就是执行构造函数，至此一个对象就已经创建完成。</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象的存储布局可以划分为三个部分：对象头、实例数据、对齐填充。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头分为两大部分数据：</p><ul><li><p>存储对象自身的运行时数据。如 HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等。</p></li><li><p>类型指针，及对象指向它的类型元数据的指针。（并不是所有虚拟机都有）</p></li></ul><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>对象真正存储的有效信息。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>HotSpot 虚拟机的自动内存管理要求对象起始地址必须是8字节的整数倍，也就是说所有对象的大小必须是8字节的整数倍，如果对象头+实例数据不满足要求，那么就要自动加上对齐填充。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java程序会通过栈上的 reference 数据来操作堆上的具体对象。reference 类型在 Java虚拟机规范中并没有定义这个引用应该通过什么方式去定位和访问，所以各个虚拟机有不同的实现，主流的访问方式有两种（HotSpot主要使用直接指针方式）：</p><ol><li><p>使用句柄池：移动对象时（垃圾收集非常常见动作）无需更改 reference 的指向，仅仅需要改变句柄池的指向。</p><img title="" src="file:///C:/Users/xieyi/AppData/Roaming/marktext/images/2022-07-24-17-13-17-image.png" alt="" data-align="inline"></li><li><p>使用直接指针：少了一次转发，速度更快。</p><img title="" src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpg" alt="" data-align="inline"></li></ol><p>    </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存区域</title>
      <link href="/2022/07/24/JVM/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2022/07/24/JVM/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><p>Java 内存区域的划分之所有网上有这么多不同的言论，主要是因为有两个原因：</p><ol><li><p>Java 版本不同；</p></li><li><p>虚拟机规范与实现上的不同。</p></li></ol><p>其中 Java 版本的不同导致的差异很好理解，而第二点主要要分清楚虚拟机规范和各个虚拟机实现，要明白 “公有设计、私有实现”的理念。即使我们绝大部分情况下接触都是 HotSpot 虚拟机，也不可将两者完全等同。</p><p>这里提到的内存区域都是运行时的内存区域，一个 Class 文件一定需要虚拟机的加载才能将对应数据存放到各个区域之间。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>当前线程所执行的字节码的行号指示器。是线程私有的。不会抛出 OOM 异常。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>虚拟机栈描述的是 Java 方法执行的线程内存模型。是线程私有的。每个方法被执行的时候，JVM会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法执行完毕后，该栈帧就会出栈。会抛出OOM异常和 StackOverflowError。</p><p>StackOverflowError: 线程请求的栈深度太深（e.g. 无限递归）；</p><p>OOM：栈扩展无法申请到内存，注意 HotSpot 虚拟机并不支持栈扩展。但是 HotSpot 虚拟机也有可能会抛出 OOM 异常，当程序无限创建新线程时，进程内存不够了就会出现OOM。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>存放这种编译器可知的各种基本数据结构、对象引用（可能是指针，也可能是句柄）、returnAddress类型。</p><p>局部变量表的存储空间以局部变量槽来表示，64位的long和double类型需要两个槽，其余只需要一个，虚拟机规范并没有指定槽的具体实现。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>作用和 Java 虚拟机栈类似，只不过服务的是本地方法（Native方法）。</p><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>堆管理着绝大部分对象实例和数组，是线程共享的。会抛出OOM异常。</p><p>虚拟机规范：所有的对象实例以及数组都应当在堆上分配。</p><p>HotSpot 实现：并不是完全遵循虚拟机规范，如栈上分配，标量替换。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>虚拟机规范：用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器变异后的缓存代码等数据。是线程共享的。会抛出OOM异常。</p><p>HotSpot 实现：</p><ul><li><p>jdk1.7 之前是用永久代实现的方法区，能够管理java堆一样管理这段内存，不用专门为方法区编写内存管理工作的代码；</p></li><li><p>jdk1.7 中，将字符串常量池、静态变量等移动到堆中；</p></li><li><p>jdk1.8 中，采用在本地内存中实现的元空间彻底代替永久代。</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区一部分。Class文件中的常量池表会存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放方法到方法区的运行时常量池中。</p><p>运行时常量池最重要的特性就是动态性，除了编译器产生的常量之外，运行期产生的常量（如String::intern）也会存放在运行时常量池。</p><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享，节省了内存空间。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>并不是java虚拟机规范中的定义的内存区域。主要是 jdk1.4 中新加入 NIO 类，引入了一种基于通道和缓冲区的I&#x2F;O方式，使用Native方法直接分配堆外内存。避免了在Java堆和Native对中来回复制数据。也会抛出OOM。</p><h1 id="面试真题（持续补充）"><a href="#面试真题（持续补充）" class="headerlink" title="面试真题（持续补充）"></a>面试真题（持续补充）</h1><h2 id="什么时候栈会出现OOM异常？"><a href="#什么时候栈会出现OOM异常？" class="headerlink" title="什么时候栈会出现OOM异常？"></a>什么时候栈会出现OOM异常？</h2><blockquote><p>答：如果是支持栈扩展的虚拟机实现，如远古时代的 Classic 虚拟机，如果程序中定义了大量的本地变量，导致此方法帧中本地变量表的查高难度很大，超过了虚拟机指定的栈容量（通过 -oss 指定），此时会出现OOM异常。</p><p>如果是不支持栈扩展的虚拟机实现，如 HotSpot 虚拟机实现，如果程序无限创建新线程并且线程一直不回收，由于单个进程内存是有上限的，最终会导致创建线程时无法申请到足够的内存，此时会出现OOM异常。</p></blockquote><h2 id="请详细说一下-Java-内存结构"><a href="#请详细说一下-Java-内存结构" class="headerlink" title="请详细说一下 Java 内存结构"></a>请详细说一下 Java 内存结构</h2><blockquote><p>答：Java 虚拟机规范中定义的 Java 内存结构可以分为程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。其中程序计数器、Java虚拟机栈、本地方法栈是线程私有的，Java堆、方法区是线程共享的。</p><p>程序计数器表示的是当前线程所执行的字节码的行号指示器。</p><p>Java虚拟机栈描述的是 Java 方法执行的线程内存模型。</p><p>本地方法栈描述的是 Native 方法执行的线程内存模型。</p><p>Java堆存放着绝大部分的对象实例和数组。</p><p>方法区存放的是被虚拟机加载的类型信息、常量、静态变量等信息。</p><p>除此之外，Java虚拟机规范中没有定义但是实际Java程序用到的内存区域叫堆外内存或者说直接内存，主要是 jdk1.4 引入的 NIO 类所使用。</p><p>需要注意的是，Java 虚拟机规范中定义的内存结构很有可能和我们常见的HotSpot虚拟机具体实现的内存结构有些差异。比如：在jdk1.7之前，HotSpot采用永久代实现方法区，而且jdk1.8时更改为了用元空间实现方法区。</p><p>另外，由于堆中是垃圾收集的主要场所，很多垃圾收集器会采用分代思想管理堆内存，但是这属于各个垃圾收集器自己的具体实现，而和 Java 虚拟机规范无关。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP笔记</title>
      <link href="/2022/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%A7%A3http/"/>
      <url>/2022/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%A7%A3http/</url>
      
        <content type="html"><![CDATA[<h2 id="《图解http》"><a href="#《图解http》" class="headerlink" title="《图解http》"></a>《图解http》</h2><h3 id="网络分层的好处"><a href="#网络分层的好处" class="headerlink" title="网络分层的好处"></a>网络分层的好处</h3><ol><li>不同层级之间的协议相互不影响</li><li>相同层级的协议之间的替换对其他层次无感</li><li>各层的协议设计更加简单</li></ol><h3 id="TCP-x2F-IP-四层协议架构和OSI七层协议架构的对比"><a href="#TCP-x2F-IP-四层协议架构和OSI七层协议架构的对比" class="headerlink" title="TCP&#x2F;IP 四层协议架构和OSI七层协议架构的对比"></a>TCP&#x2F;IP 四层协议架构和OSI七层协议架构的对比</h3><p>注：这里的硬件和网卡可以看做同一层,即数据链路层</p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/compare.png" width="600"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-|OSI推荐网络架构</span><br><span class="line">-|--| 应用层：应用相关的处理，比如说使用key/value的结构标明用户数据(username:damon)</span><br><span class="line">-|--| 表示层：数据加密，数据格式的约定(例如文本使用什么编码，音视频数据采用什么封装格式等)</span><br><span class="line">-|--| 回话层：按顺序进行传输，连接管理</span><br><span class="line">-|--| 传输层：收发的确认，专注于如何提高吞吐率，确认数据可达</span><br><span class="line">-|--| 网络层：确保通讯双方能够互相找到对方,寻址和路由选择</span><br><span class="line">-|--| 数据链路层：点对点的传输</span><br><span class="line">-|--| 物理层：比特流能够在物理媒介上进行传输,光或者电信号</span><br></pre></td></tr></table></figure><h3 id="HTTP设计原则"><a href="#HTTP设计原则" class="headerlink" title="HTTP设计原则"></a>HTTP设计原则</h3><ol><li>HTTP不保存状态<br>– 更加快速的处理大量事务<br>– 确保协议足够简洁，保证其可伸缩性</li><li>使用其他方式保证http请求在特定情况的响应速度<br>– 管线化(发出一个请求后，不需要等待请求响应就直接发送第二次请求)<br>– 长连接</li></ol><h3 id="HTTP的结构"><a href="#HTTP的结构" class="headerlink" title="HTTP的结构"></a>HTTP的结构</h3><p>用于HTTP协议交互的信息被称为HTTP报文，其结构通常为</p><ul><li>请求行：用于请求的方法，请求的URI和HTTP版本号(对什么—URI，做什么—请求的方法)</li><li>状态行：表明相应结果的状态码(404，500)，原因短语(NOT FOUND, SERVER ERROR)，和HTTP版本</li><li>首部字段(header)：包含请求和响应的各种条件和属性，一般有四种.header里面所包含的报文信息是HTTP协议里面的大头，大量的信息存放在header中</li><li>空行：用来分隔header和正文。因为header是可以用户自定义的，所以这里使用一个空行来说明所有的元数据都设置完毕</li></ul><h4 id="状态行中的状态码"><a href="#状态行中的状态码" class="headerlink" title="状态行中的状态码"></a>状态行中的状态码</h4><ul><li>1XX 表示请求正在处理</li><li>2XX 表示请求成功</li><li>3XX 表示请求重定向</li><li>4XX 表示客户端错误</li><li>5XX 表示服务端错误</li></ul><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><h5 id="header按照其实际用途分为一下四种"><a href="#header按照其实际用途分为一下四种" class="headerlink" title="header按照其实际用途分为一下四种"></a>header按照其实际用途分为一下四种</h5><ol><li><p>通用首部字段<br>也就是请求和响应都会使用这种header，代表为Cachache-Contro, Data， Via(代理服务器信息)等</p></li><li><p>请求首部字段&#x2F;请求头<br>客户端向服务端发送的请求的时候所使用头部，代表为 Host(请求资源所在服务器)， From(用户电邮), User-Agent等</p></li><li><p>响应首部字段&#x2F;响应头<br>补充了响应附加内容，也会要求客户端附加额外的内容信息，代表为Location(重定向至指定的URI), Proxy-Authenticate， Retry-after等</p></li><li><p>实体首部字段<br>针对请求&#x2F;响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息(及元数据).代表有Content-Type，Content-Language， Content-Encoding.</p></li></ol><h5 id="最常用的header之一：cookie"><a href="#最常用的header之一：cookie" class="headerlink" title="最常用的header之一：cookie"></a>最常用的header之一：cookie</h5><ul><li><p>为什么需要cookie？<br>因为http的设计就是无状态的，如果想要保存用户的个人信息，达到免登陆或者是记录上次浏览的地址等效果，则需要有一种方式能够保存当前用户的身份和状态信息，cookie就是解决这个问题的。虽然没有被编入标准化的http&#x2F;1.1中，但是在实际的web网站中，cookie得到广泛运用</p></li><li><p>cookie是怎么工作的<br>以n天内用户自动登录为例，当用户执行登录操作，提交表单，服务器在响应的头中就会添加上set-cookie，将被当前的状态信息保存下来并用sessionID作为标识。下一次用户发送http请求的时候，比如第二天，用户重新登录，发送的请求头中带有cookie:sessionID这样的字样时，服务端就能识别用户，达到自动登录的效果。(cookie的使用没有标准化，不同的web服务器可能使用可能实现不同。)</p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/cookie-usage.png" width="600"></li><li><p>其他的用户认证方式还有：Basic认证，Digest认证，SSL客户端认证，但是使用最为广泛的还是上面的这种表单认证。</p></li></ul><h4 id="HTTP的编码"><a href="#HTTP的编码" class="headerlink" title="HTTP的编码"></a>HTTP的编码</h4><ol><li>http可以编码(压缩)提升传输速率(gzip)</li><li>http的分块传输<br>– HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久连接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。<br>– 分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名<br>– 压缩时，分块传输编码可以用来分隔压缩对象的多个部分，虽然压缩是整体压缩，但是其压缩的输出使用文本描述的方案分块传输，这样可以一边压缩一边传输</li></ol><h4 id="http的其他特性"><a href="#http的其他特性" class="headerlink" title="http的其他特性"></a>http的其他特性</h4><ol><li><p>http发送多种类型的数据<br>使用MIME，比如如果使用的是表单类型，那么就使用(multipart&#x2F;from-data来表示这部分的数据类型)，使用boundary字符串来划分多部分对象集合，指明各类实体</p></li><li><p>http获取部分内容范围的请求<br>content-range:bytes 5001-10000&#x2F;10000 可以用在断点续传。</p></li><li><p>内容协商<br>中国的用户和美国的用户同时访问google，那么出来的页面是中文还是英文，也是可以通过http的内容协商来确定</p></li></ol><h4 id="与http协作的各类http服务器"><a href="#与http协作的各类http服务器" class="headerlink" title="与http协作的各类http服务器"></a>与http协作的各类http服务器</h4><ol><li>代理：可以是多级的，转发时，需要附加Via字符标记经过的主机信息<br>用途：可以作为缓存服务器，个人使用正向代理作为翻墙服务器使用。</li><li>网关：提高通信的安全性，屏蔽内部服务，可以作为一个集群的统一入口，提供统一的调用方式</li><li>隧道：按要求建立一条与服务器的通信线路，届时使用ssl等加密手段通信。</li></ol><h3 id="http协议的问题及缺点"><a href="#http协议的问题及缺点" class="headerlink" title="http协议的问题及缺点"></a>http协议的问题及缺点</h3><ol><li>通讯过程中使用明文，所有通讯内容可能被窃听<br>解法a. 使用ssl建立安全通道后，然后再这条线路上通讯。解法b.对http内容进行加密处理，但这需要通讯双方都知道加密规则</li><li>没有验证双方的身份，因此可能遭到伪装<br>客户端危害：不知道响应的是否为期望服务器<br>服务端危害：不知道客户端的身份，不知道响应数据是否真的发往了最开始发出请求的客户端，同时没有办法应对大量的恶意请求，如果知道客户端身份的话，可以设置响应频率。<br>解法a. 使用ssl验明身份。</li><li>没有办法验证受到的数据是否是期望数据，可能被篡改，可能被替换<br>确认数据是否完整和被篡改的方法常为hash值校验，而如使用md5进行校验，则网站上提供的md5结果本身，也可能被篡改。</li></ol><h3 id="解决http缺陷的答案，https"><a href="#解决http缺陷的答案，https" class="headerlink" title="解决http缺陷的答案，https"></a>解决http缺陷的答案，https</h3><p>https &#x3D; http+加密处理+认证+完整性保护.本质上https就是http+ssl,这里tls和ssl的关系是tls是在ssl的基础上开发的。</p><h4 id="加密处理"><a href="#加密处理" class="headerlink" title="加密处理"></a>加密处理</h4><ol><li>种类<br>现在的加密方法中，一般加密算法是公开的，但是加密所使用的秘钥是保密的。根据秘钥的使用方式不同分为对称加密和非对称加密。</li><li>对比<br>对称加密：加密时所使用的秘钥在通讯的双方都是相同的,这样的好处是加密所需要消耗的资源少，加密解密的效率高。但是一旦出现了秘钥泄露的情况，加密的意义也就不存在了，在互联网中不方便直接传输对称秘钥。<br>非对称加密：使用公私钥对数据进行加密和解密。其中公钥在互联网中传播，私钥只有自己本地存放。</li></ol><h4 id="https建立链接"><a href="#https建立链接" class="headerlink" title="https建立链接"></a>https建立链接</h4><p>服务端提供https服务及https通讯的大致流程如下<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/server_https.png" width="600"></p><p>客户端和服务器ssl建立连接的流程图如下所示<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/httpConnet.png" width="600"></p><h4 id="为何不将http全部替换成https"><a href="#为何不将http全部替换成https" class="headerlink" title="为何不将http全部替换成https"></a>为何不将http全部替换成https</h4><ol><li><p>https相较于http会慢2-100倍，这个慢体现在两个方面</p><ul><li>第一 ssl本身在建连接的时候(也就是握手)也是需要时间的。</li><li>第二 ssl在对内容进行加密和解密的时候需要消耗cpu，内存等资源，处理加密解密需要花费一定的时间。</li></ul></li><li><p>ssl所需要的证书本身也需要花钱。</p></li></ol><h4 id="基于http的功能追加协议"><a href="#基于http的功能追加协议" class="headerlink" title="基于http的功能追加协议"></a>基于http的功能追加协议</h4><p>当服务端经常会出现大量的更新时，期望客户端能够实时的获取更新后的内容，如果由客户端频繁去请求服务段，则造成大量的无意义请求。</p><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h5><p>利用js脚本和DOM，通过更新页面局部内容达到实时加载的效果。因为只需要更新局部内容，所以传输所带来的代价大大降低.但是依旧没有解决大量请求的问题。</p><h5 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h5><p>用户发送请求确认页面是否更新，comet先将请求挂起，一旦有可用的更新内容立即返回响应。但是为了保留响应，一次连接持续的时间也边长了。</p><h5 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h5><ul><li>多路复用：使用一个tcp连接就可以处理多个http请求</li><li>压缩http头部</li><li>推送功能：可以由服务端主动的向客户端发送数据，这样出现内容更新不需要被动等待</li><li>赋予请求优先级：</li><li>服务器提示功能：服务器可以主动提示客户端，请求所需的内容，这样如果客户端有缓存，避免不必要的请求</li></ul><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/spdy.png" width="600"><h5 id="http-x2F-1-1-队头阻塞问题"><a href="#http-x2F-1-1-队头阻塞问题" class="headerlink" title="http&#x2F;1.1 队头阻塞问题"></a>http&#x2F;1.1 队头阻塞问题</h5><ul><li>http&#x2F;1.1当中使用多路复用的情况</li></ul><ol><li>用户使用http请求访问获取<code>script.js</code>，各个网络传输协议会按下图添加各自内容<img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/hol_pic1.png" width="600"></li><li>用户此时又访问获取<code>style.css</code>网页内容，因为tcp是字节流，所以这里会将<code>style.css</code>响应的头放在上一个响应的末尾，响应的实际内容用新的tcp包存放<img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/hol_pic2.png" width="800"></li></ol><p>此时问题已经产生，加入<code>script.js</code>包很大，而<code>style.css</code>包很小，那么在接收到了pakcet3之后如果想要读取<code>style.css</code>里面的内容，必须要等到前面一个文件完全接受完毕才行（tcp保序）。即使后面的文件可能很小，但是http&#x2F;1.1没有方法能够获取这个信息.</p><h5 id="使用多路复用结局队头阻塞问题"><a href="#使用多路复用结局队头阻塞问题" class="headerlink" title="使用多路复用结局队头阻塞问题"></a>使用多路复用结局队头阻塞问题</h5><p>如果想要解决这个问题，就需要将大文件拆分成小的文件，然后交错的传输小的文件，如果以1表示第一个文件的包，2表示第二个文件的包则一个可能的例子就是原来为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111122</span><br></pre></td></tr></table></figure><p>现在改成(实际上多路复用发包的策略也是可以优化的，这里以轮询为例)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12121111111</span><br></pre></td></tr></table></figure><h5 id="http-x2F-1-1-无法使用多路复用"><a href="#http-x2F-1-1-无法使用多路复用" class="headerlink" title="http&#x2F;1.1 无法使用多路复用"></a>http&#x2F;1.1 无法使用多路复用</h5><p>当使用http1.1交错传输包时，传输js文件的首部部分，然后传输css文件的首部和第一个包，在传输第三个文件的包时，由于这里第三个文件的包里面既包含了js的数据，又包含了css文件的数据（下图三）。当http解析的时候，由于所有的数据都是纯粹的文本，所以当发送第二个包的时候，http会将第二个包中的所有数据视作第一个包也就是js文件中的剩余部分，并且在读到第1000个字节的时候停下来。在读取第三个包的时候，由于他不符合http头的格式，所以http模块也只能将第三个包丢弃，最终js的一个可能的解释结果如下图图四<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/http_multy.png" width="600"><br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/js_parser_result.png" width="600"></p><p>ps:有些场景（访问多个页面）可以使用多个tcp连接来防止多路复用导致的head of line blocking</p><h4 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h4><p>http2.前的技术所开发的新的http的规范，大量参考了SPDY里面的内容</p><h5 id="http2-0里面的多路复用"><a href="#http2-0里面的多路复用" class="headerlink" title="http2.0里面的多路复用"></a>http2.0里面的多路复用</h5><p>http1.1之所以没有办法使用多路复用的关键问题在于没有办法区分数据从哪一部分到哪一部分是属于那个http请求的，从图里可以清楚的看到，http2.0加上了一些简单的控制信息(数据帧&#x2F;data frame)，即<code>stream id</code>，同时在数据域前面加上了<code>content-length</code>和其<code>stream id</code><br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/http2_multy.png" width="600"></p><p>此时http2.0已经能够交互式的拿到数据帧并且不会出现队头阻塞问题，但是还有一个问题是需要注意的，那就是数据的传输顺序对于整体web交互的性能会产生非常的大的影响。</p><ul><li>Fair multiplexing (for example two progressive JPEGs): 12121212</li><li>Weighted multiplexing (2 is twice as important as 1): 221221221</li><li>Reversed sequential scheduling (for example 2 is a key Server Pushed resource): 22221111</li><li>Partial scheduling (stream 1 is aborted and not sent in full): 112222</li></ul><h5 id="http2-0的多路复用只是解决了应用层的队头阻塞"><a href="#http2-0的多路复用只是解决了应用层的队头阻塞" class="headerlink" title="http2.0的多路复用只是解决了应用层的队头阻塞"></a>http2.0的多路复用只是解决了应用层的队头阻塞</h5><p>首先明确一点，tcp并不知道他传输的数据的使用的是什么应用层协议。在下面这个图当中，如果tcp包1和tcp包3到达，但是此时tcp包2尚未到达&#x2F;丢包待重传，从http的角度来看，实际上此时streamId1的数据已经全部送达，但是从tcp的角度来看，由于tcp包2没有送达，所以tcp包3就会存在于缓冲区，等待tcp包2的到来，然后上传给应用程序。<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/tcp_hol.png" width="800"></p><p>ps:虽然http2.0没有解决tcp层面的队头阻塞问题，但是网络数据丢包的情况是相对少见的，从影响上来看，远不及http队头阻塞造成的影响大。</p><h4 id="总结http2-0中的改进"><a href="#总结http2-0中的改进" class="headerlink" title="总结http2.0中的改进"></a>总结http2.0中的改进</h4><ol><li>多路复用(multiplexing)：即上文描述的解决队头问题后使用一个连接同时处理多个请求(HTTP&#x2F;2 does this by splitting data into binary-code messages and numbering these messages so that the client knows which stream each binary message belongs to.)</li><li>服务推送(server push)：以抖音或者是直播为例，每秒都有大量的新数据上传，替换传统的客户端请求更改为服务端主动推送会逐渐增大应用场景。</li><li>头部压缩(header compression)：http&#x2F;2使用了HPACK算法进行压缩，减少了重复信息的发送。(This eliminates&#x2F;消除 a few bytes from every HTTP packet. Given the volume of HTTP packets involved in loading even a single webpage, those bytes add up quickly, resulting in faster loading.)</li></ol><p>ps: 这里的多路复用就包含了二进制分帧，实际上多路复用就是需要将数据以而二进制的形式封装到他的需要传输的包里面</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/">Head-of-Line Blocking in QUIC and HTTP&#x2F;3: The Details</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/performance/http2-vs-http1.1/">What are the other differences between HTTP&#x2F;2 and HTTP&#x2F;1.1 that impact performance?</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
