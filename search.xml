<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java 线程安全与锁优化</title>
      <link href="/2022/08/01/JVM/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2022/08/01/JVM/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>定义：当多个线程同时访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行文都可以获得正确的结果，那就称这个对象是线程安全的。</p><p>Java线程安全的安全程度由强至弱可以分为不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h2 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h2><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。</p><p>基本数据类型可以由final关键字修饰，就是不可变的。</p><p>对象类型的不可变有一些典型的对象，如String类的对象。</p><p>枚举类型也是不可变对象。</p><h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>对于某些对象内的线程安全的方法，可能在多个线程按照某种顺序调用仍然会出现问题：</p><p>比如线程安全的Vector类，单个get和remove方法肯定是线程安全的，但是有多个线程同时分别调用get和remove方法，可能就会导致最终抛出数组越界异常。</p><h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>就是我们通常意义上所讲的线程安全。它需要保证对这个对象的单次的操作是线程安全的，对于一些特定的顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>就是我们通常意义上所讲的线程不安全。指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境下可以安全地使用。</p><h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>指不管调用段是否采取了同步措施，都无法在多线程中并发地使用代码。如Thread类地suspend()和resume()方法。</p><h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>synchronized：该关键字经过javac编译后，会在同步块的前后分别形成monitorenter和monitorexit指令，这两个指令都需要一个reference类型的参数来指明要锁定和解锁的对象。该关键字实现的锁是可重入的、非公平的。需要从用户态转换到核心态中。</p><p>Lock接口：ReentrantLock是Lock接口最常见的手段，主要新增三个功能：等待可中断、公平锁、可绑定多个条件。</p><p>两者通过jdk6优化之后，性能差不多。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>CAS，需要硬件指令支持。在Java中，unsafe类的方法包装提供。会有ABA问题。</p><h3 id="无同步"><a href="#无同步" class="headerlink" title="无同步"></a>无同步</h3><p>可重入代码：如果一个方法的返回结果是可以预测的，不依赖全局变量、堆和其余公用数据，不调入其余非可重复方法等。</p><p>线程本地存储：常见的ThreadLocal类</p><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>由于互斥同步每次都需要从用户态转为内核态，所以可以让线程空转一段时间，避免状态的转换，但是会耗费CPU执行时间，竞争过大的时候性能会急剧下降。</p><blockquote><p>自旋锁和CAS的区别：自旋锁是锁优化的一个手段，也可以用于互斥锁；CAS单个操作是没有自旋的概念的，只是通常CAS会在while循环里面。</p></blockquote><p>自适应自旋是指JVM会在同一个锁对象上，近期自旋等待获取锁的概率比较高，那么就会允许自旋等待持续相对更长的时间，如果比较低，那么就会缩短甚至跳过自旋环节。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>对于某些没有竞争场景的加锁情况，JVM可能会支持去除掉锁的获取。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>对于某些循环下的小粒度的频繁的锁，可能会直接加一个粒度更大的锁来减少加锁&#x2F;释放锁的频率。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>相对于传统的互斥锁这种重量级锁而言，是轻量级的，采用CAS操作来减少互斥锁的加锁&#x2F;解锁释放过程。</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/Mark%20Word.png"></p><p>加锁步骤：在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为01），虚拟机首先将在当前线程的栈帧中建立一个锁记录的空间，用户存储锁对象目前Mark Word的拷贝：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png"></p><p>然后，虚拟机会使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果更新动作成功了，即代码该线程拥有了这个对象的锁，并且对象的Mark Word锁标志位会转变位00：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/Mark%20Word.png"></p><p>如果失败了，则说明目前有竞争。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，则可以直接进入同步块，如果不是，则需要膨胀为重量级锁，标志位改位01。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>比轻量级锁更加轻量，轻量级锁需要每次（即使没有竞争）使用CAS操作尝试更新对象的Mark Word。</p><p>原理：锁对象第一次被线程获取的时候，虚拟机将会把对象头重的标志位设置为01，把偏向模式设置为1。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word。如果CAS操作成功，则该线程可以直接进入同步块。如果此时有别的线程来访问，偏向锁会立刻生效，会转到无锁或者轻量级锁的模式。</p><p>此时Mark Word里面保存了线程ID，一些对象的平时hashcode没地方保存了，如果需要使用的话，偏向锁也会立刻失效</p><p>偏向锁适合在整个锁对象的生命周期只有一个线程访问，轻量级锁适合在整个锁对象的生命周期有多个线程访问但是在某一个时刻只有一个线程访问，重量级锁适合在某个时刻有多个线程访问。</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h1 id="说说Synchronized和ReentrantLock类的区别？"><a href="#说说Synchronized和ReentrantLock类的区别？" class="headerlink" title="说说Synchronized和ReentrantLock类的区别？"></a>说说Synchronized和ReentrantLock类的区别？</h1><blockquote><p>答：两者都是互斥同步的手段，不同的是前者是由java自身提供的关键字，而后者是Lock接口的一个实现类。</p><p>在使用Synchronized的时候，javac编译时会在同步代码块前后分别生成monitorenter和monitorexit，这两条字节码指令需要一个reference参数，如果锁是代码块，这个参数就是代码编写时填入的对象，如果锁的是普通方法，这个参数就是this对象，如果锁的静态方法，这个参数就是当前类的Class对象。synchonized是可重入的、非公平的，解锁动作也是自动的。</p><p>ReentrantLock是Lock接口的一个实现类，相比于Synchronized锁，它主要有三个不同：支持公平锁、支持超时中断、支持绑定多个条件，由于不是java直接支持的关键字，所以解锁时需要手动解锁，一般会在finally代码块中解锁。</p></blockquote><h2 id="说说锁有什么类型？"><a href="#说说锁有什么类型？" class="headerlink" title="说说锁有什么类型？"></a>说说锁有什么类型？</h2><blockquote><p>答：从公平角度来看，分为公平锁和非公平锁；</p><p>公平锁说的是多个线程等待锁的过程中，必须按照申请锁的时间来获取锁；而非公平锁不保证这些。</p><p>从可重入角度来看，分为可重入锁和不可重入锁；</p><p>可重入锁说的是同一个线程，能够重复反复进入同步块而不会死锁；而不可重入锁则不能重复进入；</p><p>从悲观乐观的角度来看，可以分为悲观锁和乐观锁；</p><p>悲观锁指的是每次进入同步块都需要进行先加锁操作，而乐观锁则是使用CAS的原子指令，去进行无锁操作。</p><p>从锁的优化角度来看，可以分为自旋锁、偏向锁、轻量级锁、重量级锁；</p><p>我们常说的传统互斥锁也被称为重量级锁，是因为每次如果获取锁失败时，就会由用户态转为内核态，这种切换是需要耗费很多处理器时间的，因此为了减少这种状态转化的频率，java推出了自旋锁、偏向锁、轻量级锁的概念。</p><p>自旋锁指的是，线程获取锁失败的时候，不直接转入阻塞态，而是做一段时间的空转，这样在锁竞争相对不激烈的情况，可以避免状态转化的开销。但是缺点是空转也需要CPU执行时间，如果在锁竞争激烈的情况下，自旋锁的性能可能会比互斥锁还低。另外，由于自旋时间或者说循环次数是不太好把控的，所以java还提出了自适应自旋的概念，指的是对于同一个加锁对象，如果在近期自旋获取锁的成功概率比较高，那么就会适当提升自旋时间，如果进去自旋获取锁的成功率比较低，那么久会较少自旋时间或者干脆不进行自旋。</p><p>偏向锁的目的是消除数据在无竞争情况下的同步原语。是说锁对象在第一次被线程获取的时候，虚拟机会在对象头中设置对应的标识位来标识锁对象目前处于偏向模式，并且通过CAS在对象头中设置当前线程ID。如果成功了，那么当前线程后续再次进入同步块的时候就无需加锁操作了，如果没有成功或者由另外一个线程访问，则偏向锁会膨胀为轻量级锁。</p><p>轻量级锁的目的也是减少使用重量级锁的频率。是说线程即将进入同步块的时候，会将线程当前的栈帧中保存对象头MarkWord的副本，然后采用CAS的方式更新MarkWord的标志位并在对象头中记录线程栈帧的指针，如果CAS成功，则代表该线程持有锁，允许同步块，如果CAS不成功，则轻量级锁会膨胀为重量级锁。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存模型与线程</title>
      <link href="/2022/07/29/JVM/Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/07/29/JVM/Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果的模型。</p><p>Java内存模型主要目的是定义程序中各种变量的访问规则，关注在虚拟机中把变量值存储到内存或从内存中取出变量值这样的底层细节。</p><blockquote><p>注意，本章节所说的内存模型均是一种理论规则的模型，具体的实现可以随着具体实现的编译器和虚拟机的不同而不同。其中，差异比较大的是：</p><p>目前JSR规定的volatile关键字部分，暂时只定义了多个volatile变量的有序性，并没有强调volatile变量和普通变量的有序性，虽然java通过内存屏障等技术实现了volatile变量和普通变量的有序性，但是这并不是java内存模型所要求&#x2F;规范的。</p></blockquote><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据，不同的线程也无法直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存。</p><blockquote><p>这里所将的主内存、工作内存与Java内存区域中的堆、栈等并不是同一个层次对内存的划分。两者基本上是没啥关系。</p></blockquote><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/JMM.png"></p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>关于主内存和工作内存具体的交互协议，java内存模型定义了以下操作来完成，JVM实现时必须保证下面提及的每一种操作都是原子的。</p><table><thead><tr><th>操作</th><th>作用于</th><th>作用</th><th>时机</th></tr></thead><tbody><tr><td>lock</td><td>主内存变量</td><td>将变量标识为线程独占的状态</td><td></td></tr><tr><td>unlock</td><td>主内存变量</td><td>将处于锁定状态的变量释放出来</td><td></td></tr><tr><td>read</td><td>主内存变量</td><td>将变量的值从主内存传输到线程的工作内存中</td><td></td></tr><tr><td>load</td><td>工作内存变量</td><td>将read操作得到的变量值放入工作内存的变量副本中</td><td></td></tr><tr><td>use</td><td>工作内存变量</td><td>将工作内存中变量的值传递给执行引擎</td><td>需要使用变量的值的时候使用</td></tr><tr><td>assign</td><td>工作内存变量</td><td>从执行引擎接收的值赋值给工作内存变量</td><td>给变量赋值时使用</td></tr><tr><td>store</td><td>工作内存变量</td><td>将工作内存中的一个变量的值传送到主内存中</td><td></td></tr><tr><td>write</td><td>主内存变量</td><td>把store操作从工作内存中的得到变量的值放入主内存变量中</td><td></td></tr></tbody></table><p>这几种操作的工作流程如下：<img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/JMM_op.png" alt="preload"></p><p>除了这些操作都必须是原子性的之外，java内存模型还规定了执行上述操作时必须满足如下规则：</p><ul><li><p>不允许read和load、store和write操作之一单独出现；</p></li><li><p>不允许一个线程丢弃它最近的assign操作；</p></li><li><p>不允许一个线程无原因（即没有发生过任何assign操作）地把数据从线程地工作内存同步回主内存；</p></li><li><p>一个新的变量只能在主内存中诞生；</p></li><li><p>一个变量在同一时刻只允许同一个条内存进行lock操作，但是是可重入的；</p></li><li><p>如果对一个变量执行load操作，那将会清空工作内存中的值；需要重新初始化</p></li><li><p>不允许unlock未被lock的变量；</p></li><li><p>执行unlock，需要先将变量同步回主内存。</p></li></ul><p>这些复杂的操作和严格的规则共同在JVM层间保证了并发安全，换句话说，如果某些代码不符合这些规则，那么并发安全就得不到保证。从这个层面上看，这些操作和规则可以等效于先行发生原则。</p><h2 id="对于volatile变量的特殊规则"><a href="#对于volatile变量的特殊规则" class="headerlink" title="对于volatile变量的特殊规则"></a>对于volatile变量的特殊规则</h2><p>volatile是java的一个关键字，是jvm提供的最轻量级的同步机制。为了实现volatile的语义，java内存模式为volatile专门定义了一些特殊的访问规则（这些个规则均是马上所有提到的正式规定里更加通俗的说法）：</p><ul><li><p>保证此变量对所有线程的可见性，当一条线程修改了这个变量的值，新值对于其他线程来说是立刻可以得知的；</p></li><li><p>禁止指令重排序优化。</p></li></ul><p>实现原理是在volatile修饰的变量赋值之后会自动生成一条lock字节码指令。该指令既相当于一个内存屏障以禁止该指令前后的代码重排序（实现了有序性）。也会引起别的内核无效化缓存，相当于store和write操作（实现了可见性）。</p><p>Java内存模型的正式规定为：</p><ul><li><p>在use volatile变量时，必须同时出现load和read动作，在assign volatile变量时，必须同时出现store和write动作。</p></li><li><p>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q</p><blockquote><p>注意：该条规则仅仅保证了两个volatile变量之间的有序性，对于volatile变量和普通变量，Java对volatile实现是通过内存屏障实现的，但是这并不是JMM的规范。<a href="https://gee.cs.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook</a></p></blockquote></li></ul><p>值得注意的是，以上两点并不能完全保证volatile变量的原子性，在某些诸如i++的场景，由于i++本身并不是原子操作，所以即使volatile变量能保证可见性，也不能保证原子性。用volatile保证原子性的要满足以下两条规则：</p><ol><li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；</p></li><li><p>变量不需要与其他的状态变量共同参与不变约束。</p></li></ol><h2 id="针对long和double变量的特殊规则"><a href="#针对long和double变量的特殊规则" class="headerlink" title="针对long和double变量的特殊规则"></a>针对long和double变量的特殊规则</h2><p>Java内存模型对于64位的数据类型，允许虚拟机的具体实现自行选择是否要保证64位数据类型的操作原子性。</p><p>对于32位x86平台下的HotSpot虚拟机，确实会出现非原子性访问的风险。</p><h2 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h2><p>Java内存模型是围绕在并发过程中如何处理原子性、可见性、有序性这三个特征来实现的。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指对于一个变量的修改，要么修改成功，要么修改失败，不会出现“一半失败，一半成功”这种诡异的现象。</p><p>基本数据类型的访问、读写都是具备原子性的，但是如果需要一个更大范围内（如i++）的原子性保证，java内存模型提供了lock和unlock指令，这两个指令在字节码层面上就是monitorenter和monitorexit两个操作，在语言层次上就是synchronized关键字。</p><p>因此，对于更大范围内的原子性保证，单纯的volatile关键字是无法满足的。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</p><p>Java内存模型定义了volatile的特殊规则保证了volatile能够保证可见性——新值能够立即同步到主内存以及每次使用前必须从主内存加载。</p><p>synchornized关键字也是可以保证可见性的，主要规则是：</p><ul><li><p>对一个变量执行unlock操作之前，必须先执行store、write操作将其同步回主内存；</p><blockquote><p>在同步代码块中，每次访问代码都需要先执行lock指令，执行完之后，才会将变量同步至工作内存中；只有执行完unlock指令之后，才允许其余线程执行lock指令。因此不会出现以下的并发场景：</p><p>线程A先将同步代码块中的变量加载至工作线程，此时线程B进入同步代码块进行修改该变量并同步回主内存，线程A读取到工作线程中未被修改的旧值。</p></blockquote></li></ul><p>final关键字也能保证可见性，这种可见性是指：一旦final修饰的字段在构造器被初始完成，就永远不会被修改，无须同步就能被其他线程正确访问。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>是指代码执行的结果不会受到指令重排序的影响。</p><p>volatile关键字是由Java内存模型专门给它定义的规则来实现的：禁止指令重排序，Java内存模式</p><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到。该原则是判断数据是否存在竞争，线程是否安全的非常有用的手段。</p><p>下面是Java内存模型默认的先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码直接使用。</p><ul><li><p>程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。；</p></li><li><p>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作；</p></li><li><p>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作；</p></li><li><p>线程启动规则：Thread对象的start()先行发生于此线程的每一个动作；</p></li><li><p>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行；</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生；</p></li><li><p>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始；</p></li><li><p>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论；</p></li></ul><h1 id="Java-与线程"><a href="#Java-与线程" class="headerlink" title="Java 与线程"></a>Java 与线程</h1><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>主流的操作系统实现线程主要有三种方式：使用内核线程实现（1:1）；使用用户线程实现（1:N）；使用用户线程加轻量级进程混合实现（N:M）</p><h3 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h3><p>内核线程（KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换和调度。程序一般不会直接使用内存线程，而是使用内核线程的一种高级接口——轻量级线程（LWP），轻量级线程就是我们通常意义上所说的线程。</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BA%BF%E7%A8%8B.png"></p><p>优点：每个轻量级线程都成为一个独立的调度单位，即使其中某一个轻量级线程在系统调用中被阻塞了，也不会影响整个线程继续工作。</p><p>缺点：各种线程操作都需要切换至内核态进行操作；由于每个轻量级进程都需要有一个内核线程支持，因此轻量级线程需要消耗一定的内核资源。</p><h3 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h3><p>是指完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的切换和调度完全在用户态中完成。</p><p>  <img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B.png"></p><p>优点：完全由用户自定义实现，操作可以非常快速且低消耗，也能够支持更大的线程数量。</p><p>缺点：实现复杂。</p><h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>将内核线程与用户线程一起使用的实现方式。</p><img title="" src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E6%B7%B7%E5%90%88%E7%BA%BF%E7%A8%8B.png" alt="" data-align="inline"><p>同时具备两者的优点和缺点。</p><h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java虚拟机实现并没有定义一个明确的规范，各个虚拟机实现完全可以自由发挥。以HotSpot为例，每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot会将所有的线程操作全部交由操作系统去处理。</p><p>线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是完全透明的。</p><h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度是指系统为线程分配处理使用权的过程，主要分为协同式线程调度和抢占式线程调度。</p><ul><li><p>协同式线程调度：每个线程工作完成之后，主动通知系统切换至另外一个线程。</p><ul><li><p>优点：实现简单；</p></li><li><p>缺点：不可控；</p></li></ul></li><li><p>抢占式线程调度：每个线程由系统来分配时间，线程可以主动让出执行时间，但是不能主动获取执行时间。</p></li></ul><h4 id="Java线程优先级"><a href="#Java线程优先级" class="headerlink" title="Java线程优先级"></a>Java线程优先级</h4><p>java的线程优先级仅仅是我们建议操作系统分配更多时间的一种手段，这种手段是不稳定的：</p><ul><li><p>会受到优先级映射的影响：如果操作系统的线程优先级等级定义比java的更少，那么必然有在java中不同优先级的线程映射至操作系统相同优先级的线程；</p></li><li><p>会受到操作系统对线程优先级变更影响：某些操作系统线程优先级可能会被操作系统变更。</p></li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p>Java线程有六个状态：</p><ol><li><p>新建：创建后尚未启动；</p></li><li><p>运行：处于此状态的线程有可能正在运行，也有可能正在等待操作系统为它分配执行时间；</p></li><li><p>无限期等待（Waiting）：不会被分配处理器执行时间，需要被其他线程显式唤醒</p><ul><li><p>没有设置tiemout参数的Object::wait()方法；</p></li><li><p>没有设置timeout参数的Thread::join()方法；</p></li><li><p>LockSupport::park()方法；</p></li></ul></li></ol><p>4* 有限期等待：不会被分配处理器执行时间，在一定时间后由系统自动唤醒</p><ul><li><p>Tread::sleep()方法；</p></li><li><p>有设置tiemout参数的Object::wait()方法；</p></li><li><p>有设置timeout参数的Thread::join()方法；</p></li><li><p>LockSupport::parkNanos()方法；</p></li><li><p>LockSupport::parkUnitl()方法；</p></li></ul><p>5* 阻塞：线程被阻塞了，在程序等待进入同步区域的时候，线程将进入这种状态，需要等待获取到一个排它锁；</p><p>6* 结束：已经终止的线程。</p><p>线程转换关系如图：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%BA%BF%E7%A8%8B%E8%BD%AC%E5%8C%96%E5%85%B3%E7%B3%BB.png"></p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="说说Java内存模型？"><a href="#说说Java内存模型？" class="headerlink" title="说说Java内存模型？"></a>说说Java内存模型？</h2><blockquote><p>答：Java内存模型是java设计者为了屏蔽各种硬件和操作系统访问内存的差异，所定义出来的一套规范。</p><p>Java内存模型模型规定了所有线程将会共享主内存，且每个线程有自己私有的工作内存空间。一个变量只能存放至主内存，线程的工作内存中保存了主内存变量的副本，线程对变量操作只能在工作内存中进行，不能直接直接读写主内存，各个线程也不能访问其余线程的工作内存空间，多个线程之间必须通过主内存共享变量。</p><p>为了实现这个目标，Java内存模型定义了八种工作内存和主内存交互的原子操作，并且为这些操作定义了一些规则。线程如果需要从主内存读取变量值，依次需要经过read、load、use操作，如果需要写回主内存，则依次需要经过assign、store、write操作，另外还定义了lock和unlock两个操作。</p><p>从另外一个角度来看，Java内存模型是围绕在并发过程如何处理原子性、可见性、有序性这三个特征来建立的。</p><p>在java中，主要有两种操作具有原子性：</p><ol><li><p>对基本数据类型的读写操作：通过read&#x2F;load&#x2F;use&#x2F;assign&#x2F;store&#x2F;write操作实现；</p></li><li><p>synchonized代码块：通过lock和unlock实现，这两个操作在字节码层面对应的是monitorenter和monitorexit。</p></li></ol><p>在java中，有以下关键字保证了变量的可见性：</p><ol><li><p>volatile：JMM定义了在修改volatile变量时，需要马上同步至主内存中；而在读取volatile变量时，需要从主内存中读取。</p></li><li><p>synchonized：主要是通过unlock操作实现的，执行unlock操作之前，必须将其同步至主内存中。</p></li><li><p>final：主要是说变量一旦被定义，就不会被修改，自然满足可见性。</p></li></ol><p>在java中，有以下关键字保证了线程之间的有序性：</p><ol><li><p>volatile：</p></li><li><p>synchonized：</p></li></ol><p>除了这两个关键字之外，java还提供了先行发生原则来保证可用性。</p></blockquote><h2 id="线程和进程的区别是什么？"><a href="#线程和进程的区别是什么？" class="headerlink" title="线程和进程的区别是什么？"></a>线程和进程的区别是什么？</h2><blockquote><p>答：进程是操作系统分配资源的最小单位，线程是CPU调度的最小单位；</p><p>进程是重量级的，线程是轻量级的；</p><p>线程在进程下进行，一个进程可以包含多个线程；</p><p>进程要比线程消耗更多的计算机资源；</p><p>不同进程间数据很难共享，同一进程下不同线程间数据很易共享</p><p>…</p></blockquote><h2 id="Java线程有哪些状态？"><a href="#Java线程有哪些状态？" class="headerlink" title="Java线程有哪些状态？"></a>Java线程有哪些状态？</h2><blockquote><p>答：java线程有六种状态，分别是：</p><ul><li><p>新建：创建后尚未启动；</p></li><li><p>运行：处于此状态的线程有可能正在运行，也有可能正在等待操作系统为它分配执行时间；</p></li><li><p>无限期等待（Waiting）：处于这个状态的线程不会被分配处理器执行时间，需要被其他线程显式唤醒，能够将线程状态改为无限期操作的动作有：</p><ul><li><p>没有设置tiemout参数的Object::wait()方法；</p></li><li><p>没有设置timeout参数的Thread::join()方法；</p><p>…</p></li></ul></li><li><p>有限期等待：处于这个状态的线程也不会被分配处理器执行时间，但在一定时间后由系统自动唤醒。能够将线程状态改为无限期操作的动作有：</p><ul><li><p>Tread::sleep()方法；</p></li><li><p>有设置tiemout参数的Object::wait()方法；</p></li><li><p>有设置timeout参数的Thread::join()方法；</p><p>…</p></li></ul></li><li><p>阻塞：线程被阻塞了，需要等待获取到一个排它锁才能够改为运行状态，在程序等待进入同步区域的时候，线程将进入这种状态，；</p></li><li><p>结束：已经终止的线程。</p></li></ul></blockquote><h2 id="说说volatile关键字，它是用来做什么的？有什么局限性？和synchronized关键字有什么区别？"><a href="#说说volatile关键字，它是用来做什么的？有什么局限性？和synchronized关键字有什么区别？" class="headerlink" title="说说volatile关键字，它是用来做什么的？有什么局限性？和synchronized关键字有什么区别？"></a>说说volatile关键字，它是用来做什么的？有什么局限性？和synchronized关键字有什么区别？</h2><blockquote><p>答：volatile是java提供的一种轻量级的同步机制，用于修饰变量，用户该变量在多个线程之间的同步读操作。如果一个线程修改了该变量，那么其余线程会立即得知。另外，volatile还保证了有序性，禁止指令中排序。</p><p>volatile主要用于能够确保只有一个线程能够修改变量的场景，如用双重检查锁实现单例模式。</p><p>相比和synchronized的区别主要在于：</p><p>volatile是轻量的，synchronized是重量的；</p><p>volatile不能保证代码块的原子性，而synchronized是可以保证的，比如，对一个变量进行自增操作，尽管代码量只有一行，但是该操作是一个典型的代码块操作。</p><p>两者都能保证变量的可见性和代码的有序性。</p></blockquote><h2 id="volatile和synchronized是怎么实现的？"><a href="#volatile和synchronized是怎么实现的？" class="headerlink" title="volatile和synchronized是怎么实现的？"></a>volatile和synchronized是怎么实现的？</h2><p>待整理</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 字节码执行引擎</title>
      <link href="/2022/07/29/JVM/JVM%20%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2022/07/29/JVM/JVM%20%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>执行引擎是JVM核心的组成部分之一，在java虚拟机规范中制定了Java虚拟机字节码执行引擎的概念模型，这个概念模型成为不同虚拟机执行引擎的统一外观。从外观上来看，所有的java虚拟机的执行引擎出入、输出都是一致的。</p><p>java虚拟机解释执行引擎被称为基于栈的执行引擎。</p><h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><p>栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的虚拟机栈的栈元素。</p><p>栈帧中局部变量表和操作数栈大小会在编译java程序源码时候，由编译器计算出来。</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E6%A0%88%E5%B8%A7.png"></p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。里面的元素，long和double者两个64位的数据类型需要两个槽来存放，但是由于栈是线程私有的，所以不会有并发问题。</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>也被称为操作栈，是一个后入先出的栈。</p><h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p><p>符号引用转换为直接引用时，有两种方式：</p><ol><li><p>静态解析：在类加载阶段或者第一次使用的时候转换，是静态的；</p></li><li><p>动态连接：在每一次运行期间都转化为直接引用，是动态的；</p></li></ol><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>两种退出正在执行的方法的方式：</p><ol><li><p>正常调用完成：执行引擎遇到任意一个返回的字节码指令；</p></li><li><p>异常调用完成：方法执行中遇到了异常，并且这个异常没有在方法体内得到处理；</p></li></ol><p>方法退出的过程实际上等同于把当前栈帧出栈。</p><h2 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h2><p>允许各个虚拟机自己实现。</p><p>一般会把动态连接、方法返回地址和其他附加信息全部归为一类，称为栈帧信息。</p><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>该阶段唯一的任务就是确定被调用方法的版本。Class文件编译的过程中不包含传统程序编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，调用目标必须在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析。</p><p>主要有静态方法和私有方法两种。具体的有：</p><ol><li><p>静态方法</p></li><li><p>私有方法</p></li><li><p>实例构造器</p></li><li><p>父类方法</p></li><li><p>final 方法</p></li></ol><p>以上这些被称为非虚方法，其余方法被称为虚方法。解析调用是一个静态的过程，不必延迟到运行期再去完成。</p><h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>静态类型和实际类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 man 继承 Human</span></span><br><span class="line"><span class="comment">// 这条语句中，man变量的静态类型是Human，实际类型是Man</span></span><br><span class="line"><span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在java中，静态类型一定是编译器就可以确定的，但是实际类型却不一定，如：</span></span><br><span class="line"><span class="comment">// 实际类型变换</span></span><br><span class="line"><span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">Random</span>()).nextBoolean() ? <span class="keyword">new</span> <span class="title class_">Man</span>() : <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line"><span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> (Man) <span class="keyword">new</span> <span class="title class_">Human</span>;</span><br></pre></td></tr></table></figure><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>所有依赖静态类型来决定方法执行的版本的分派动作，都称为静态分派。静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段。</p><p>不同方法的参数只看静态类型，而不看实际类型，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticDispathc</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Human human)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, guy!&quot;</span>);</span><br><span class="line">    &#125;                                  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Man man)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, man!&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Woman woman)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, woman!&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        <span class="type">Human</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">        <span class="type">StaticDispatch</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticDispatch</span>();</span><br><span class="line">            <span class="comment">// 这段代码中，无论传进去的变量实际类型是Man还是Woman，只要实际类型是Human，就只会进入第一个方法</span></span><br><span class="line">        sd.sayHello(man);</span><br><span class="line">        sd.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// hello, guy!</span></span><br><span class="line"><span class="comment">// hello, guy!</span></span><br></pre></td></tr></table></figure><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>动态分派主要体现在重写。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDispathc</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, man!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, woman!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        <span class="type">Human</span> <span class="variable">woman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// hello, man!</span></span><br><span class="line"><span class="comment">// hello, woman!</span></span><br></pre></td></tr></table></figure><p>出现这种情况的本质在于invokevirtual指令的运作过程，该指令并不是把常量池中的方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法的版本。</p><p>这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><p>既然是invokevirtual指令底层实现的，那么针对于字段，自然没有动态分派这一说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldHasNoPolymorphic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">            money = <span class="number">2</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMeTheMoney</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I&#x27;m Father, i have &quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> extend Father &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">            money = <span class="number">4</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMeTheMoney</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I&#x27;m Son, i have &quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">gay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;This gay has&quot;</span> + gay.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// I&#x27;m Son, i have 0;</span></span><br><span class="line"><span class="comment">// I&#x27;m Son, i have 4;</span></span><br><span class="line"><span class="comment">// This gay has 2;</span></span><br></pre></td></tr></table></figure><p>输出两句都是“I am Son”，这是因为Son类在创建的时候，首先隐式调用了Father的构造函数，而Father构造函数中对showMeTheMoney()的调用是一次虚方法调用，实际执行的版本是Son::showMeTheMoney()方法，所以输出的是“I am Son”。而这时候虽然父类的money字段已经被初始化成2了，但Son::showMeTheMoney()方法中访问的却<br>是子类的money字段，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。<br>main()的最后一句通过静态类型访问到了父类中的money，输出了2。</p><h3 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h3><p>方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派。Java是一门静态多分派、动态单分派的语言。</p><h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>JVM会对每一个类型在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能。</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E8%99%9A%E6%96%B9%E6%B3%95.png"></p><p>虚方法表中存放各个地址的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类方法的地址入口时一直的。如果子类重写了这个方法，子类虚方法表中的地址也会被替换指向子类实现版本的入口地址。</p><h1 id="动态语言支持"><a href="#动态语言支持" class="headerlink" title="动态语言支持"></a>动态语言支持</h1><p>主要是invokedynamic指令。</p><p>动态语言支持通过java.lang.inovke包实现，总体来说和反射的功能差不多，但是invokedynamic是JVM字节码指令上的支持，可以支持不仅限于java的语言。</p><h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><p>java既有传统的字节码解释执行部分，也有如即时编译器编译执行的部分。</p><h2 id="基于栈的指令集和基于寄存器的指令集"><a href="#基于栈的指令集和基于寄存器的指令集" class="headerlink" title="基于栈的指令集和基于寄存器的指令集"></a>基于栈的指令集和基于寄存器的指令集</h2><p>栈：</p><ul><li><p>可移植，不受到硬件的约束；</p></li><li><p>频繁出栈入栈需要访问内存，速度较慢。</p></li></ul><p>寄存器：</p><ul><li><p>速度较快；</p></li><li><p>受底层硬件影响。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 类加载机制和类加载器</title>
      <link href="/2022/07/28/JVM/Java%20%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2022/07/28/JVM/Java%20%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>类加载机制：JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程。</p><blockquote><p>Class文件：语言无关性和平台无关性的基石，JVM不与包括Java语言在内的任何程序语言绑定，它只和Class文件这种特定的二进制文件格式所关联。JVM不关心Class文件的来源，各个语言都能实现自己编译器，将各种语言编译成Class文件。</p></blockquote><p>Class文件不仅仅可以是具体的磁盘文件，而是一串特定格式的二进制字节流，包括但不限于磁盘文件、网络、数据库、内存或动态产生。</p><p>类加载的过程分为以下阶段</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></p><p>其中，除了解析阶段可以在初始化之后开始，其余的都需要按照顺序来开始。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>Java虚拟机规范只规定了在哪些场景下必须立即对类进行初始化。</p><p>以下场景都有一个前提：只有类没有被初始化才会触发类的初始化</p><ol><li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，能够生成这些指令的典型Java代码有：</p><ul><li><p>new关键字；</p></li><li><p>读取或设置static字段（不是static final字段）；</p></li><li><p>调用一个类型的static方法；</p></li></ul></li><li><p>使用reflect包进行反射调用时；</p></li><li><p>初始化类时需要先初始化父类；</p></li><li><p>虚拟机启动时，需要初始化包含main方法的那个类；</p></li><li><p>当一个接口实现了default关键字时，如果有该接口的实现类触发了初始化，那么该接口会先初始化；</p></li><li><p>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p></li></ol><p>除了以上六种情况，其余情况均不会触发类的初始化，如：</p><ul><li><p>通过子类引用父类的静态变量；</p></li><li><p>引用一个类的常量；</p></li><li><p>通过数组引用一个类，不会触发该类的初始化；</p></li><li><p>初始化一个接口时，不会触发父接口；</p><p>…..</p></li></ul><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>将JVM外部的二进制字节流按照虚拟机所设定的格式存储在方法区之中，并在内存生成对应的Class对象作为访问入口。</p><p>JVM主要做三件事：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流；包括但不限于从ZIP压缩包中读取；从网络中获取；运行时计算生成（动态代理技术）；从数据库中读取；从加密文件中获取……</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</p></li><li><p>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口；</p></li></ol><p>加载动作需要类加载器来帮忙实现，关于类加载器，稍后还会详细讲解。</p><p>另外，对于数组类型（这里说的就是”数组“这个类型，而非具体数组类里的元素类型）来说，情况稍有不同。数组类本身不通过加载器创建，它是由JVM直接在内存中动态构造出来的。数组类型加载的规则如下：</p><ul><li><p>如果数组类型的组件类型（指数组去掉一个维度的类型）是引用类型，那么会递归（主要针对多维数组）的进行数组类型的加载，并将数组C表示在加载该组件类型的类加载器的类名称空间下；</p></li><li><p>如果数组类型不是引用类型，JVM会把数组C标记为与引导类型加载器关联；</p></li><li><p>数组类的可访问性和数组类型的可访问性一致，如果类型不是引用类型，默认为public。</p></li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>保证Class文件中的字节流包含的信息符合Java虚拟机规范的约束，保证这些信息被当作代码后不会危害虚拟机自身的安全。</p><p>尽管Java对源代码进行编译限制，但是由于Class文件的来源不确定，所以需要加上验证的阶段。</p><p>验证大致上会分成下面四个阶段的动作：</p><ol><li><p>文件格式验证：验证字节流是否符合Class文件格式的规范，保证输入的字节流能正确地解析并存储于方法区内，如版本号是否被JVM接受。经过这个阶段之后，接下来所有的信息都会从方法区获取；</p></li><li><p>元数据验证：对字节码描述地信息进行语义分析，保证描述的信息符合Java语言规范，如这个类是否有父类；</p></li><li><p>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的，如保证任何跳转指令不会跳转到方法体之外的字节码指令上；</p></li><li><p>符号引用验证：对类自身意外的各类信息进行匹配性校验，如在符号引用中通过字符串描述的全限定名是否能找到对应的类。</p></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类中定义的静态变量分配内存并设置类变量初始值。</p><p>对只有static的字段生成的是对应的零值；对static + final修饰的字段生成的是对应设置的值。</p><p>注意java虚拟机规范和具体虚拟机实现的区别：java虚拟机规范仅仅要求将静态变量存放至方法区中，而在jdk8之后的HotSpot虚拟机中，这些变量都会随着Class对象一起存放在堆区中。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>Java虚拟机将常量池的符号引用替换为直接引用的过程。</p><p>符号引用：符号引用以一组符号来描述所引用的目标，可以是任何形式的字面量（如，一个类中的静态变量，可以是类的全限定名+字段名组合而成的字面量）。</p><p>直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能够简介定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类构造器<clinit>()方法的过程。</p><p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，只能赋值不能访问。</p><p>该方法不会显式的调用父类构造器，JVM会保证该方法执行之前，父类的<clinit>()方法已经执行完毕。如果一个类中没有静态语句块，也没有对静态变量的赋值，那么编译器可以不生成该方法。另外，接口中对变量的赋值也会让编译器为接口生成该方法，但是不会保证父类接口的<clinit>()方法执行（详情可以参考类加载的时机）。</p><p>另外，该方法在多线程的情况需要保证只有一个线程执行该方法。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器：在类加载的过程中，需要通过一个类的全限定名来获取描述该类的二进制字节流，实现这个功能的代码被称为类加载器。</p><h2 id="类和类加载器"><a href="#类和类加载器" class="headerlink" title="类和类加载器"></a>类和类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确定其在JVM中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，判断一个类是否相等，只能在同一个类加载的前提下，比较才是有意义的。</p><h2 id="类加载器模型"><a href="#类加载器模型" class="headerlink" title="类加载器模型"></a>类加载器模型</h2><h3 id="三层类加载器"><a href="#三层类加载器" class="headerlink" title="三层类加载器"></a>三层类加载器</h3><p>在jdk8及之前版本的java引用，绝大多数程序都会使用到以下3个系统提供的类加载器来进行加载</p><ul><li><p>启动类加载 Bootstrap ClassLoader：负责加载存在<JAVA_HOME>\lib目录及被-Xbootclasspath参数指定的目录，并且JVM能够识别的类。如果需要把加载请求委派给启动类加载器去处理，直接使用null代替即可。</p></li><li><p>扩展类加载器 Extension ClassLoader：负责加载<JAVA_HOME>\lib\ext目录或者被java.ext.dirs系统变量所指定的路径中所有类库的类。</p></li><li><p>应用程序类加载器 Application ClassLoader：负责加载用户类路径（classpath）下所有的类库中的类。</p></li></ul><p>3个类加载器关系如图：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B1%82%E6%AC%A1.png"></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>指的是一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载去完成，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会去尝试自己去完成加载。</p><p>优点是Java中的类随着它的类加载器一起具备了一种带有优先级的层次管理。如类java.lang.Object，无论哪个类加载器要加载这个类，最终都会由bootstrap ClassLoader类加载器去完成加载。反之，如果没有使用双亲委派模型，用户自己编写了一个名为java.lang.Object类，并放在 ClassPath中，那系统中就会出现多个不同的Object类。如果尝试的话，会发现这个类无法被加载运行。</p><p>核心代码如下：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%A3%E7%A0%81.png"></p><h4 id="双亲委派模型的破坏"><a href="#双亲委派模型的破坏" class="headerlink" title="双亲委派模型的破坏"></a>双亲委派模型的破坏</h4><ul><li><p>在jdk1.2双亲委派模型出现之前；</p></li><li><p>自身缺点，比如基础类型要调用用户的代码，如JNDI、JDBC等等。以JNDI为例，JNDI是java的一个标准服务，但是在工作的时候需要调用ClassPath下的JNDI服务提供者接口的代码，此时启动类加载器肯定是不认识ClassPath下的实现类的。为了解决这个问题，java引入了线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过Thread::setContextClassLoader方法进行设置该线程的上下文类加载器，如果创建线程时未设置，它将从父线程中继承一个，如果全局都没有这是，这个类加载器默认就是应用程序类加载器了。有了线程上下文类加载器，JNDI服务使用这个线程上下文类加载器加载所需的SPI服务代码。</p></li><li><p>java语言对程序的动态性支持。</p></li></ul><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="类加载的过程有哪些？"><a href="#类加载的过程有哪些？" class="headerlink" title="类加载的过程有哪些？"></a>类加载的过程有哪些？</h2><blockquote><p>答：类加载的过程可以分为加载、连接、初始化，其中连接阶段又可以分为验证、准备、解析。</p><p>加载阶段主要是将一个静态的二进制文件流按照虚拟机规范存储在方法区内，并在堆中生成一个对应的Class对象作为访问入口。</p><p>验证阶段主要是验证Class文件的字节流是否符合java虚拟机规范的约束，保证这些信息不会危害虚拟机自身的安全。该阶段大致上会完成四个阶段的校验：</p><ol><li><p>文件格式校验；</p></li><li><p>元数据校验；</p></li><li><p>字节码校验；</p></li><li><p>符号引用校验；</p></li></ol><p>准备阶段主要是为类变量分配内存并设置初始化值，其中static类变量会分配对应的零值，static final 变量会直接分配定义好的值。</p><p>解析阶段主要是将符号引用转化为直接引用。</p><p>初始化阶段主要是执行类构造器（主要是类构造器，而不是构造函数）<clinit>()方法，该方法是编译器自动生成的。</p></blockquote><h2 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h2><blockquote><p>答：双亲委派模型是类加载时的一种机制。具体指的是当一个类加载收到类加载的请求时，会优先让父类加载器区加载这个类。</p><p>java中类加载器是有结构层次的，由上至下可以分为：</p><ol><li><p>启动类加载器，主要加载<JAVA_HOME>\lib下的类；</p></li><li><p>扩展类加载器，主要加载<JAVA_HOME>\lib\ext下的类；</p></li><li><p>应用程序类加载，主要加载Java应用下的ClassPath路径的类；</p></li></ol><p>双亲委派模型是java设计者推荐给开发者的一种类加载器实现的机制。它能够保证类可以拥有和类加载器类似的层次结构，比如Object类，无论是哪个类想要加载该类，双亲委派模型都保证了这个类必须是由启动类加载器加载的，从而保证了java程序稳定。</p></blockquote><h2 id="什么是线程上下文类加载器？它有什么用？"><a href="#什么是线程上下文类加载器？它有什么用？" class="headerlink" title="什么是线程上下文类加载器？它有什么用？"></a>什么是线程上下文类加载器？它有什么用？</h2><blockquote><p>答：java设计者推荐开发者去使用双亲委派模型实现类加载动作。但是该模型是有一定缺陷的，比如有以下场景：</p><p>java定义了一套访问的标准接口JDBC，需要调用由各个厂商实现并部署在ClassPath下的JDBC服务提供者接口。JDBC这种通用的设计肯定是比较基础的服务，需要由启动类加载器去加载该类，但是启动类加载器加载不了ClassPath下的各个实现类。所以java引入了线程上下文类加载器，在JDBC中代码中，可以拿到这个线程上下文加载器去加载所需要的JDBC实现类，从而代替默认由加载当前类的类加载器也就是启动类加载器加载JDBC实现类的这种行为。</p><p>这个类加载器可以通过Thread::setContextClassLoader方法进行设置，如果创建线程的时候没有设置，那么线程会从父线程继承一个，如果整个应用都没设置的话，默认就是应用程序类加载器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 垃圾收集器</title>
      <link href="/2022/07/26/JVM/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2022/07/26/JVM/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><p>”经典“是相对于jdk 11之后出现的低延迟垃圾收集器而言的，这些成熟的垃圾收集器仍然是 jdk8 之前重要的选择。在 G1 收集器出现之前，大多数垃圾收集器都采用分代思想，将java堆内存至少分为新生代和老年代，并且不同区域之间由于对象存活特性的不同，各个垃圾收集器针对的区域、选择的算法都有差异。</p><p>各个垃圾收集器之前能够组合的关系如下图，只有用线连起来的垃圾收集器才能够混合使用。其中CMS和Serial Old的连线是代表当CMS收集器发生失败的情况时，Serial Old将作为后备垃圾收集器。</p><p>其中 Serial、ParNew、CMS三种垃圾收集器使用HotSpot提供的分代框架，而其余垃圾收集器是自己额外实现的。所以CMS只能搭配Serial或者ParNew使用。</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%80%BB%E8%A7%88.png"></p><h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>采用复制算法，在垃圾收集时必须暂停其余所有线程，并且垃圾收集工作线程是单线程的。该收集器优点是：简单而高效，消耗额外内存最少。</p><p>仍然适合客户端模式下的java程序。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>是 Serial 收集器的多线程版本，这里说的多线程，是在垃圾收集时的工作线程可以多线程并行工作。</p><p>采用复制算法，在垃圾收集时必须暂停其余所有线程。由于很多服务端模式下java应用在老年代使用了CMS收集器，所以该收集器是很多服务端模式下java应用采用的收集器。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>采用复制算法，其余的和ParNew收集器差不多。但是前面两种收集器不同，Parallel Scavenge收集器主要关注的是吞吐量，主要适合在后台运算而不需要太多的交互的分析任务。</p><p>该收集器也被称为”吞吐量优先收集器“，该收集器还提供了垃圾收集的自适应调节策略，只要开启了开关-XX：+UseAdaptiveSizePolicy，就不需要人工指定新生代大小、Eden和Servivor比例等细节参数，而是JVM会根据当前系统的运行情况，动态的设置这些参数达到一个比较好的吞吐量或者停顿时间。</p><h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><p>需要说明的是，以下三种收集器虽然理论上是仅针对老年代的收集器，但是只有CMS中才会有”仅针对老年代（称为Old GC或Major GC）“的收集，其余两种在进行老年代收集时同时会触发新生代收集（称为 Full GC）。所以，也只有CMS需要考虑老年代收集时，新生代的对象持有了老年代的对象这种跨代引用的情况，在这种情况下，需要将整个新生代作为GC Roots来进行扫描。</p><blockquote><p>老年代对象持有新生代对象引用的解决办法是引入记忆集和卡表的方法解决的。</p></blockquote><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>采用标记整理算法，是Serial收集器的老年代版本。在垃圾收集时也是需要暂停用户线程，主要用于客户端模式下的java应用，或者服务端下的java应用作为cms收集器的预备方案。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>采用标记整理算法，时Parallel Scavenge收集器的老年代版本，是JDK 6之后才提供的，至此，如果是关注吞吐量的任务，可以采用 Parallel Scavenge + Parallel Old 收集器，这也是JDK 9之前的默认选择。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>采用标记-清除算法。CMS收集器主要关注的是停顿时长，适合基于浏览器的B&#x2F;S系统或者互联网网站。</p><p>主要分为四个步骤：</p><ol><li><p>初始标记：需要暂停用户线程，仅仅标记GC Roots能直接关联到的对象，速度很快；</p></li><li><p>并发标记：不需要暂停用户线程，遍历整个对象图，耗时较长；</p></li><li><p>重新标记：需要暂停用户线程，主要通过增量更新的方式标记第2步改动的对象；</p></li><li><p>并发清除：不需要暂停用户线程，清理掉已经被标记为垃圾的对象。</p></li></ol><p>总的来说，垃圾收集中最耗时的第二步和第四步是可以和用户线程并发进行，所以整体的暂停时长会比较短。工作的流程如图：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/CMS.png"></p><p>缺点：</p><ol><li><p>需要占用一部分线程，导致程序的总吞吐量下降；</p></li><li><p>无法处理浮动垃圾，只能留在下一次垃圾收集清理；而且在并发清除的过程中，用户线程还在持续运行，JVM不得不留有一部分内存以供用户分配。问题在于，如果留有内存较大，那么GC的频率就会相应变高；如果留有内存较小，那么可能会导致用户线程无法分配到足够的内存导致启动预备方案：暂停所有用户线程，临时启动Serial Old收集器进行垃圾收集。</p></li><li><p>会有内存碎片产生；解决的方法时，如果不得不进行内存整理了，那么会暂停用线程来整理内存碎片，这样就会导致停顿时间的增加。</p></li></ol><h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><p>G1 收集器整体上采用的是标记-整理算法，局部采用的复制算法。</p><p>是JDK第一款出现的跨代收集器，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1 收集器的期望是，在停顿时间可控的前提下，去追求更高的吞吐量。相比于CMS，G1做出的重要思想转变就是将GC这种”大成本“的操作改为单次成本更小的操作。在G1之前，所有的垃圾收集器都是回收整个区域（新生代或者老年代或者整堆），而G1则是将整个堆划分为多个小区域，GC时，根据具体的选择算法，选择出回收收益最大的区域。虽然G1总体上仍然是基于分代的思想，但是单次回收的衡量标准不再是它属于哪个分代，而是基于收益的来确定回收的区域，这种模式被称为Mixed GC模式。</p><blockquote><p>选择算法更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，优先处理回收收益最大的Region。</p></blockquote><p>G1 Region布局：把连续的Java堆划分为多个大小相等的的独立区域（Region），每一个Region根据需要都可以扮演新生代的Eden，Survivor或者老年代空间；针对于大对象，会根据对象的大小有两种处理方式：</p><ul><li><p>如果对象大于整个Region的一半，那么会采用Humongous Region区域来存放；</p></li><li><p>如果对象大于整个Region，那么会采用多个连续的Humongous Region区域来存放。</p></li></ul><p>Humongous Region区域被看做是老年代的一部分。</p><p>G1的复杂之处：</p><ol><li><p>将Java堆中分成多个独立的Region之后，跨代引用如何解决？</p><p>思路仍然是通过记忆集和卡表的方式避免全堆作为GC Roots扫描，只是由于G1中的Region区域很多，需要单独为每一个Region建立卡表，并且卡表数据结构需要保存引用该Region的其余Region的地址。在Shenandoah中，采用了连接矩阵来实现此功能。</p><p>由于Region的数量明显会比分代的数量多得多，所以需要更大的额外内存来做这些工作，根据经验，G1额外内存会占据整堆的10%~20%。</p></li><li><p>如何在并发标记阶段保证收集线程和用户线程互不干扰？</p><p>和CMS不同，该过程产生的新的引用对象是通过原始快照（STAB）解决的。此外在每一个Region上，G1分配了两个名为TAMS（Top at Mark Start）指针，并发回收时分配新内存必须要在这两个指针的区域之间，这块区域里的对象会在当次GC中默认是存活的对象。另外，和CMS类似，如果内存回收速率赶不上内存分配速率，最终仍然会导致Full GC。</p></li><li><p>如何建立可预测的停顿时间模型？</p><p>G1收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。筛选均值和均值相比就是更加注重”最近“的情况。</p></li></ol><p>G1收集器大致分为四个步骤：</p><ol><li><p>初始标记：需要暂停用户线程，标记一下GC Roots能直接关联的对象，并且修改TAMS指针的值；</p></li><li><p>并发标记：不需要暂停用户线程，遍历整个对象图，耗时较长；</p></li><li><p>最终标记：需要暂停用户线程，标记第2步产生的新的对象应用关系，采用的方式为原始快照，速度很快；</p></li><li><p>筛选回收：需要暂停用户线程，筛选出价值最高的Region区域，并将这些Region里的对象移动至新的Region中，由于G1收集器并需要将所有Region区域的垃圾都进行清除，所以该阶段的耗时较短并可控。暂停用户线程进行还可以获得较大的吞吐量。</p></li></ol><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/G1.png"></p><p>G1相比于CMS的优点：</p><ol><li><p>没有内存碎片；</p></li><li><p>可以指定最大停顿时间；</p></li></ol><p>G1相比于CMS的缺点：</p><ol><li><p>占用内存过高，主要体现在每个Region都需要维护一份卡表；</p></li><li><p>占用CPU过高，主要体现在原始快照和增量更新这两种算法上。</p><blockquote><p>CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索 （SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。</p></blockquote></li></ol><h1 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h1><p>衡量垃圾收集器的最重要的指标：</p><ul><li><p>内存占用；</p></li><li><p>吞吐量；</p></li><li><p>延迟；</p></li></ul><p>这三者有人证明了不可能同时具有完美的表现，通常只能同时达成两项。其中延迟是目前我们主要关心的地方，而CMS和G1在这方面也并不是完美的，而且随着堆容量的扩展，这两款收集器的延迟时间也会随之变长。</p><p>CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何优  化改进，在设计原理上避免不了空间碎片的产生，随着空间碎片不断淤积最终依然逃不过“Stop The  World”的命运。G1虽然可以按更小的粒度进行回收，从而抑制整理阶段出现时间过长的停顿，但毕竟也还是要暂停的。</p><p>在两款低延迟垃圾收集器中，ZGC的单次停顿更短，通常在10ms以下；而Shenandoah收集器的吞吐量相对更高一些。</p><h2 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h2><p>shenandoah 收集器可以看作是G1收集器的升级版。有很多和G1类似的地方，最主要的地方如下：</p><ol><li><p>支持并发的整理。这点是和其余的收集器最核心的差别。如果能够暂停用户线程，那么整理是比较简单的，如果需要和用户线程并发执行，那么必须要考虑移动过程中，对象的移动和所有引用该对象的引用地址更改需要同时进行。shenandoah是采用Brooks Pointer指针实现的。</p></li><li><p>不使用分代收集；</p></li><li><p>记忆集变成了连接矩阵，降低了记忆集的开销，也降低了发生伪共享的概率。</p></li></ol><p>核心流程的如下：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/Shenandoah.png"></p><p>其中，蓝色的区域代表的是被选入回收集的Region，绿色部分就代表还存活的对象，蓝色就是用户线程可以用来分配对象的内存Region。主要分为三大部分：</p><ol><li><p>并发标记；</p></li><li><p>并发回收；</p></li><li><p>并发引用更新。</p></li></ol><p>其中，并发回收和并发引用更新都需要依赖Brooks Pointer（转发指针）。Brooks Pointer的示意图如下：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/BrooksPoint.png"></p><p>转发指针带来的好处就是，当对象拥有一份新的副本，只需要修改一处指针的值。但是修改的时候必须考虑并发问题，实际上是通过CAS的方式实现的。</p><p>另外，转发指针带来了缺点：</p><ol><li><p>访问对象多了一次开销；</p></li><li><p>访问对象的频率是十分高频的，Shenandoah收集器是通过读屏障实现的，因此读屏障需要特别注意性能问题，风险很高。</p></li></ol><h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>ZGC的内存布局其实和G1以及Shenandoah差不多，只不过它的Region分为三种：</p><ol><li><p>小型Region：固定为2MB，用于放置小于256KB的对象；</p></li><li><p>中型Region：固定为32MB，用户放置大于等于256KB但是小于4MB的对象；</p></li><li><p>大型Region：容量不固定，必须是2MB的整数倍。</p></li></ol><p>ZGC最核心的差异点仍然是整理阶段，在ZGC中，是采用的染色指针的技术来实现的。</p><p>考虑以下场景：判断一个对象是否是垃圾，其实只需要关心这个对象的引用，而不必关心这个对象本身，所以实现对象的标记有不同的实现方式：</p><ul><li><p>直接记录在对象头上，如Serial收集器；</p></li><li><p>单独维护一个结构，如G1、Shenandoah；</p></li><li><p>直接把标记信息记在引用对象的指针上。</p></li></ul><p>染色指针通过将指针的前4为作为标记位加上多重映射（为了保证操作系统能够正常支持寻址）来实现这个方式。</p><p>通过染色指针主要可以直接确认以下三个点：</p><ol><li><p>引用对象的三色标记状态；</p></li><li><p>是否进入了重分配集；</p></li><li><p>是否只能通过finalize()方法才能被访问到；</p></li></ol><p>染色指针有以下优势：</p><ol><li><p>可以确保某个Region的存活对象被移走之后，这个Region能够立刻被清理，而不用等待所有指向这个Region的所有引用都被修正之后；</p></li><li><p>可以大幅减少内存屏障；</p></li><li><p>可扩展；</p></li></ol><p>ZGC的工作流程：</p><p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/ZGC.png"></p><p>其中和其余收集器有着关键差别的有：</p><ul><li><p>并发标记：标记不是在对象上，而是在指针上；</p></li><li><p>并发预备重分配：统计本次收集要清理哪些Region，组成重分配集；</p></li><li><p>并发重分配：该阶段是核心阶段，需要将重分配集中的对象复制到新的Region上，并为重分配集中的每一个Region维护一个转发表。当有线程同时访问重分配集的对象时，这次访问将会被预置的内存屏障捕获，会将访问转发到新复制的对象上，并且更新引用的值，这个过程称为”自愈“；</p></li><li><p>并发重映射：类似Shenandoah的并发引用更新，只不过ZGC由于有自愈的存在，该动作并不紧急，所以会选择在下一次GC的并发标记阶段执行。</p></li></ul><p>ZGC的缺点：</p><ol><li>能够承受的对象分配速率不高，因为ZGC中没有分代的概念，所以每次垃圾收集都是针对全堆的，即使停顿时间叫短，但是整个流程会比较长。如果分配速率很高，那么在本次垃圾收集历程还没有结束就会有大量的对象被新分配，久而久之触发Full GC。</li></ol><p>ZGC的额外优点：</p><ol><li><p>支持”NUMA-Aware“内存分配。</p><blockquote><p>NUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种为多处理器或者多核处理器的计算机所设计的内存架构。由于摩尔定律逐渐失效，现代处理器因频率发展受限转而向多核方向发展，以前原本在北桥芯片中的内存控制器也被集成到了处理器内核中，这样每个处理器核心所在的裸晶（DIE）[12]都有属于自己内存管理器所管理的内存，如果要访问被其他处理器核心管理的内存，就必须通过Inter-Connect通道来完成，这要比访问处理器的本地内存慢得多。在NUMA架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p></blockquote></li></ol><h1 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h1><p>考虑以下几点：</p><ul><li><p>应用的关注点是什么？如吞吐量还是延迟；</p></li><li><p>应用运行的基础设施是什么？如硬件规格和操作系统架构；</p></li><li><p>JDK发行商和版本；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 引用类型</title>
      <link href="/2022/07/25/JVM/Java%20%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/07/25/JVM/Java%20%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java 为了更好的描述“引用”和对象的关系，在jdk1.2时期，对引用的概念进行了扩充，分为强引用、软引用、弱引用、虚引用四种</p><h1 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h1><p>强引用是最传统的引用定义，是指在程序代码中普遍存在的引用赋值。例如“Object obj &#x3D; new Object()” 这种，如果一个引用为强引用，那么JVM宁愿抛出OOM异常，也不会对该引用的对象进行垃圾回收。</p><h1 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h1><p>软引用是用来描述一些还有用，但是非必须的对象。系统如果内存足够，那么垃圾回收不会清理这些对象，只有即将抛出OOM异常的时候，才会将这些对象进行二次回收来释放更多的空间。jdk1.2 使用 SoftReference 类来实现软引用。</p><h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><p>弱引用和软引用的功能类似，但是它的强度比软引用更弱一下，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。jdk1.2提供了 WeakReference 类实现弱引用。</p><h1 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h1><p>虚引用也被成为“幻影引用”或者“幽灵引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2版之后提供了 PhantomReference 类来实现虚引用。</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Java-引用类型有哪些？"><a href="#Java-引用类型有哪些？" class="headerlink" title="Java 引用类型有哪些？"></a>Java 引用类型有哪些？</h2><blockquote><p>答：Java 引用类型是jdk1.2版本提出的概念，在此之前的 Java 引用类型就是传统意义上的指针概念。而 Java 为了能够更好的描述对象，如希望某些对象内存充足的时候能够保留在内存中，内存不足的时候进行垃圾回收，对引用的概念进行了扩充。</p><p>引用分为强引用、软引用、弱引用、虚引用，这4种引用的强度逐渐降低。</p><p>强引用就是传统的引用定义，如 Object obj &#x3D; new Object() 这段代码的 obj 就是一个强引用，JVM 在任何时候都不会对强引用引用的对象进行垃圾回收，即使抛出OOM异常也不会；</p><p>软引用的强度比强引用弱一些，主要体现在JVM会在内存不足也就是即将抛出OOM的时候对这些引用的对象进行垃圾回收，可以使用 SoftReference 来实现软引用；</p><p>弱引用的强度比软引用更弱一些，主要体现JVM在每次垃圾回收时，都会对弱引用引用的对象进行垃圾回收，可以使用 WeakReference 来实现弱引用；</p><p>虚引用是最弱的引用类型，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。可以使用 PhantomReference 类来实现虚引用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java finalize</title>
      <link href="/2022/07/25/JVM/finalize()%20%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/25/JVM/finalize()%20%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h1><p>finalize() 方法并不完全等同于C、C++中的析构函数，而仅仅是Java刚诞生时让C、C++程序员更容易接受Java所做出的一种妥协。</p><p>它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已经被官方明确标记为不推荐的语法。在实际生产工作最好不要用到。</p><h2 id="垃圾回收中的finalize"><a href="#垃圾回收中的finalize" class="headerlink" title="垃圾回收中的finalize()"></a>垃圾回收中的finalize()</h2><p>在垃圾回收中的可达性分析算法中，会给标记为“垃圾”的对象进行再一次的筛选：在这些“垃圾”对象中会筛选出满足条件的对象。筛选需要同时满足以下两个条件：</p><ol><li><p>finalize() 方法未被JVM调用过；</p></li><li><p>对象覆盖了finalize()方法；</p></li></ol><p>如果该对象同时满足以上两个条件，那么JVM会将该对象放置到一个名为F-Queue的队列之中，并在稍后由一条JVM自动建立的优先级较低的Finalizer线程去执行它们的 finalize() 方法。如果该对象在 finalize() 方法中重新将对象和一个GC Roots 引用链关联起来，那么该对象就可以“逃脱”此次垃圾收集。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 偏门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 垃圾收集</title>
      <link href="/2022/07/25/JVM/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
      <url>/2022/07/25/JVM/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>垃圾收集需要解决三件事情</p><ol><li><p>哪些内存需要回收？</p></li><li><p>什么时候回收？</p></li><li><p>如何回收？</p></li></ol><h1 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h1><p>主要解决 “哪些内存需要回收” 问题，主流的算法有两种，分别为引用计数法和可达性分析算法。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>基本思路：在对象中添加一个引用计数器，每当有一个地方引用该对象时，计数器值加一；引用失效时，计数器值减一；任何时刻计数器为0的对象就是不能再被使用的。</p><p>优点：原理简单，判定效率高；</p><p>缺点：占用额外的内存空间；最致命的缺点是，很难解决类似多个对象循环引用的场景。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>基本思路：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。</p><p>固定可以作为GC Roots的对象，主要在全局性的引用和执行上下文：</p><ul><li><p>全局性引用：</p><ul><li><p>方法区中常量引用的对象；</p></li><li><p>方法区中静态属性引用的对象；</p></li><li><p>Java 虚拟机内部的引用，如基本类型对应的Class对象，常驻的异常对象，系统类加载器。</p></li></ul></li><li><p>执行上下文：</p><ul><li><p>Java 虚拟机栈中引用的对象，比如参数、局部变量、临时变量等等；</p></li><li><p>本地方法栈中引用的对象；</p></li><li><p>持有同步锁（Synchronized关键字）的对象；</p></li></ul></li></ul><p>除了固定的GC Roots之外，各个垃圾收集器会根据当前回收的区域不同，可能会将其他对象临时性的加入。最典型的是局部回收，比如新生代回收时需要考虑老年代持有新生代对象的引入。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>分代收集理论是一套符合大多数程序运行实际情况的经验法则。它包含两个内容：</p><ol><li><p>弱分代假说：绝大多数对象都是朝生夕灭的。</p></li><li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p></li></ol><p>从上面两个假说可以推出第三个经验法则：</p><ol start="3"><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>这两个分代假说共同奠定了多款常用的垃圾收集器一致的设计原则：收集器应当将Java堆划分出不同的区域。然后将回收对象依据年龄分配到不同的区域。在Java堆划分出不同的区域之后，垃圾收集器才可以只回收其中某些部分的区域；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。</p><p>针对于具体的商用JVM，设计者一般至少会把Java堆划分为新生代和老年代两个区域。</p><p>通常能够单独发生垃圾收集的仅仅是新生代，实际上除了CMS收集器，其余收集器都不存在只针对老年代的收集。</p><p>GC术语说明：</p><ul><li><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</p><ul><li><p>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新年代的收集；</p></li><li><p>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的收集，目前只有CMS收集器会有这种行为。</p></li></ul></li><li><p>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</p></li><li><p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p></li></ul><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成之后，统一回收掉所有被标记的对象。</p><p>缺点：</p><ol><li><p>执行效率不稳定，两个过程的执行效率都随对象数量的增长而增长；</p></li><li><p>会产生大量的内存碎片；</p></li></ol><h2 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h2><p>简称复制算法。将可用的内存分为两块，每次只使用其中一块，用完之后将这块内存还存活的对象复制到另外一块里面区，然后将这个内存清理掉。</p><p>缺点：</p><ol><li><p>如果多数对象是存活的，会产生大量的复制开销；</p></li><li><p>浪费内存。</p></li></ol><p>针对浪费内存这一点，可以依据分代收集里面第一条。将新生代里面的区分分为一块较大的Eden区和两块较小的Survivor区。默认大小比例为8:1:1。每次发生垃圾回收时，将Eden和正在使用的Servivor区进行垃圾回收，将仍让存活的对象复制进另外一块未使用的Servivor区。这样虽然一定程度上解决了浪费内存的问题（只浪费新生代10%，而不是50%），但是也引入了新问题：如果Survivor区已经放不下一次Minor GC存活的对象，那么就需要将这些对象直接进入老年代，这种行为称为<code>分配担保</code>。</p><h2 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2><p>该算法主要针对老年代的，主要实现为在标记完哪些对象是垃圾之后，不是直接对这些对象进行清除，而是让所有存活的对象向内存空间一端移动，避免出现内存碎片。</p><p>优点：不会出现内存碎片，在分配对象内存空间时，仅仅采用移动指针方式分配即可，非常高效；</p><p>缺点：在老年代中，存活的对象较多，移动起来的开销和风险都很大。</p><p>从垃圾收集的停顿时间来看，不移动对象停顿时间更短；从程序吞吐量来说，由于分配对象的动作频率远远高于垃圾回收的频率，所以移动对象的整体吞吐量更高。</p><p>除此之外，还有一种“中庸”的方式，那就是先采用标记清除，等内存碎片化程度已经影响到对象分配了，再采用标记整理收集一次。典型代表就是CMS收集器。</p><h2 id="HotSpot-算法细节实现"><a href="#HotSpot-算法细节实现" class="headerlink" title="HotSpot 算法细节实现"></a>HotSpot 算法细节实现</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>GC Roots 主要为全局性的引用和执行上下文，在一个Java 程序中，这些对象是很多的，并且方法区和栈中不仅仅只存放引用类型，其余如基本类型也是有可能存放的，如果遍历整个方法区和栈，无疑会带来很多开销。而且根节点枚举是必须要暂停用户线程的。</p><p>HotSpot是通过一种名为<code>OopMap</code>的结构额外保存所有的GC Roots对象的，该结构也是HotSpot实现<code>准确式GC</code>算法的。</p><blockquote><p>准确式GC：不管是根对象，还是派生对象，都标记其类型。JVM中引入外部数据结构OopMap+OopMapBlock实现了该算法。</p></blockquote><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>HotSpot在OopMap的帮助下实现了较快且准确的GC Roots枚举，但是引起GC Roots对象引用关系变更的动作非常之多，如果对每一个这样的动作都保存一份OopMap，开销无疑是巨大的。因此，HotSpot引入了安全点的概念，安全点就是HotSpot为了节省上述开销，选取的<code>特定位置</code>来记录OopMap。也就是说，用户线程只有在安全点上才能够暂停。</p><p>安全点的选取一般都是能够让程序长时间执行的指令，如方法调用、循环跳转、异常跳转等。</p><p>线程跑到最近安全点的具体实现方式有两种，现在一般都是采用主动式中断：</p><ol><li><p>抢先式中断：如果线程当前没有在安全点，那么就让线程再执行一会，直到到达安全点为止；</p></li><li><p>主动式中断：当垃圾收集需要暂停线程时，不直接对线程进行操作，而是仅仅设置一个标志位，各个线程在执行过程中会不断的轮训这个标志位，一旦这个标志位为真，那么用户线程就会在最近的安全点主动中断挂起。</p></li></ol><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点是针对于能过获取CPU的线程来说的，如果一个线程没有被分配到CPU，那么就没有继续往下执行的能力，在获取下一个CPU时间之前，是永远不可能到达安全点的。</p><p>因此，HotSpot引入安全区域的概念，安全区域可以看作是安全点的拉伸，在此区域内，GC Roots的引用关系不会发生变化，也就是说在这区域内的任意位置，都是安全的。</p><p>线程在进入安全区域的时候，会标识自己已经进入了安全区域，此时JVM如果发生垃圾收集需要暂停线程时就不用管该线程，；线程在即将退出安全区域的时候，需要检查JVM暂停用户线程的阶段是否已经过了，如果没有过，那么就不允许线程退出安全区域。</p><h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><p>记忆集主要用于解决跨代引用效率的问题。在新生代中，会通过一个记忆集的数据结果保存老年代那些引用了新生代对象的对象，在GC开始之前，会将记忆集中的所有对象就加入到GC Roots中区。</p><p>卡表是记忆集的一种实现方式，主要思想就是记忆集中不保存具体的对象，而是保存连续的一段内存，每当这段内存中有对象引用了新生代对象时，就会将其标识为脏内存。在GC时，只要筛选出卡表中变脏的元素，就可以轻易得出哪些内存区域包含跨代指针。</p><p>“变脏”这个动作是通过写屏障来实现的。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>写屏障可以看作是虚拟机层面上对”引用类型字段赋值“这个动作的AOP切面，在引用对象赋值时会产生一个通知，供程序执行额外的动作。写屏障根据赋值的时机分为写前屏障和写后屏障，大多数垃圾收集器使用的都是写后屏障。</p><p>应用写屏障之后，虚拟机就会为所有的赋值操作生成响应的指令，这也会产生额外的开销。</p><p>除了写屏障的开销，卡表在高并发场景下还面临”伪共享“问题。</p><h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>这里说的并发可达性分析，主要是在GC Roots已经扫描完成，接下来就是根据GC Roots对象继续往下遍历得到存活的对象了。和根节点枚举相比较，这一部分是耗时很长的，如果这个时间段也暂停用户线程，那么影响会非常大，这是不可以接受的。</p><p>如果在一个快照（引用关系不变）上面进行遍历，原理是十分简单的，我们引用三色标记作为工具来说明，整个堆对象可以标记成以下三种颜色的一种：</p><ul><li><p>黑色：表示对象已经被垃圾收集器访问过，并且这个对象持有的所有引用也已经遍历过了（仅仅是直接引用，引用的引用不计算）。</p></li><li><p>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过；</p></li><li><p>白色：表示对象没有被垃圾收集器访问过。</p></li></ul><p>在并发标记的过程中，由于引用关系会变，所以可能会有以下影响：</p><ol><li><p>把原本消亡的对象标记为存活，产生浮动垃圾，这个影响较小；</p></li><li><p>把原本存活的对象标记为消亡，这是不可以接受的。</p></li></ol><p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p><ol><li><p>赋值器插入了一条或多条从黑色对象到白色对象的新引用。</p><p>可以通过增量更新来解决这个问题：如果有这种引用的插入，那么需要将此次插入涉及到的黑色对象记录下来，等整个并发标记的流程走完之后，重新遍历记录下来的黑色对象，重新标记需要暂停用户线程。（CMS采用这种）</p></li><li><p>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p><p>可以通过原始快照来解决这个问题：如果有这种引用的删除，那么需要将此次删除涉及到的灰色对象记录下来，等整个并发标记的流程走完之后，重新遍历记录下来的灰色对象，重新标记需要暂停用户线程。（G1、Shenandoah采用这种）</p></li></ol><h1 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h1><p>Java虚拟机规范中提到，虚拟机可以不实现方法区的垃圾回收，事实上也确实有某些收集器，如 jdk11 的ZGC，没有实现或者说没有完整实现方法区的垃圾回收。方法区收集收集的性价比也远远比不过堆区的垃圾收集。</p><p>方法区主要有回收两部分内容：</p><ol><li><p>废弃的常量：这部分内容和java堆区的垃圾收集非常类似；</p></li><li><p>不再使用的类型：判断一个类是否未被使用条件比较苛刻，必须满足以下条件：</p><ol><li><p>该类的所有实例均已被回收；</p></li><li><p>加载该类的类加载器已经被回收；</p></li><li><p>该对象对应的Class对象没有在任何地方被引用。</p></li></ol><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。</p></li></ol><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="在JVM垃圾收集有哪些算法？"><a href="#在JVM垃圾收集有哪些算法？" class="headerlink" title="在JVM垃圾收集有哪些算法？"></a>在JVM垃圾收集有哪些算法？</h2><blockquote><p>答：  垃圾收集算法主要有标记清除、标记复制、标记整理算法三种。</p><p>其中三种垃圾收集算法都有“标记”阶段，这个阶段主要是判断一个对象是否为“垃圾”，这个阶段又可以分为引用计数法和可达性分析算法。</p><p>三种垃圾算法中主要差异点在第二阶段，也就是真正清理垃圾的阶段。</p><p>标记清除算法直接将标记阶段标记的对象进行清理；</p><p>标记复制算法则是将整个回收区域分为两块，每次进行对象分配时只会使用其中一块，触发垃圾收集时，会将正在使用的区域内存活的对象复制到另外一块未使用的区域中，然后再将之前使用的区域全部清理掉。</p><p>标记整理算法则是标记阶段标记的对象不直接进行清理，而是让所有的对象全部移动到内存区域的一端。</p><p>三种算法各有优劣：</p><p>其中标记清除算法主要优点是具体收集的时候执行效率高，体现在单次垃圾回收的时候停顿时间短，缺点是会产生垃圾碎片，影响对象分配内存时的效率；</p><p>标记复制算法主要优点是不会产生内存碎片，而且相比于标记整理算法，效率更高（我理解标记复制算法在标记的过程中，将存活对象直接复制到另外一个区域；而标记整理算法需要标记所有对象之后，再进行统一的整理），缺点是浪费空间，并且需要额外的空间进行<code>分配担保</code>;</p><p>标记整理算法主要优点是不会产生内存碎片，主要缺点是在有大量存活对象的时候，移动对象的操作成本很高、风险很大。</p><p>之所以会有几种算法的不同，是因为目前大多数虚拟机都基于分代收集理论，根据不同区域下对象的特性来分区域进行垃圾回收的。总的来说，java堆至少分为新生代和老年代，其中新生代中绝大部分对象存活时间较短，老年代中大部分对象存活时间较长，并且对象大部分情况来说是分配至新生代的。所以新生代更适合不会产生内存碎片且清理效率较高的标记复制算法，而老年代更适合采用标记清除算法或者标记整理算法。</p><p>针对新生代的标记整理算法，并不需要完全按照1:1的空间比例来进行分割，而是根据经验值，默认分为一个较大的Eden区和两个较小的Servivor区，每次分配新对象时在Eden区分配，垃圾收集时同时将Eden和一块Servivor区的存活对象复制到另外一个Servivor区即可。</p><p>针对老年代的标记清理和标记整理算法的选择，各个垃圾收集器的选择不同，总的来说标记清理算法会使得本次垃圾收集停顿时间较短，但是会产生内存碎片，慢慢的影响到对象分配内存的效率；而使用标记整理算法会使得本次垃圾收集停顿时间相对较长，但是不会产生内存碎片，因为对象分配的频率远远高于垃圾收集的频率，所以采用标记整理算法可以使得Java程序总的吞吐量上升。另外还有一种“中庸”的选择，就是先采用标记清理算法，等内存碎片已经影响到了对象分配了，再使用标记整理算法来一次性消灭掉内存碎片。</p></blockquote><h2 id="在Java垃圾回收中，如果判定一个对象是否为”垃圾“？"><a href="#在Java垃圾回收中，如果判定一个对象是否为”垃圾“？" class="headerlink" title="在Java垃圾回收中，如果判定一个对象是否为”垃圾“？"></a>在Java垃圾回收中，如果判定一个对象是否为”垃圾“？</h2><blockquote><p>答：在垃圾回收中，如何哪种垃圾回收算法，都需要对一个对象进行”标记“，用于真正清理时的依据，主流的垃圾标记算法有两种：</p><p>引用计数法和可达性分析算法。</p><p>引用计数法的原理比较简单，就是在对象中额外开辟一小段空间，来存储该对象被引用的次数，如果该对象被引用的次数为0，那么即可认为该对象是垃圾。</p><p>可达性分析算法的基本思路，是通过一系列的”GC Roots“对象作为起点，根据引用关系向下搜索，如果某个对象在遍历完所有的GC Roots仍然搜索不到，即不可达，那么即可认为该对象是垃圾。</p><p>引用计数法的优势是原理简单、判定效率高，但是由于某些场景的存在，具体实现起来比较困难，如很难解决循环引用的问题，所以在Java 垃圾回收中，主要采用的是可达性分析算法。</p></blockquote><h2 id="哪些对象可以作为GC-Roots"><a href="#哪些对象可以作为GC-Roots" class="headerlink" title="哪些对象可以作为GC Roots?"></a>哪些对象可以作为GC Roots?</h2><blockquote><p>答：如果不考虑分代收集的影响，默认作为GC Roots 主要分为三部分：</p><p>第一种为全局性的引用，其中包括静态属性引用的对象和常量属性引用的对象；</p><p>第二种为当前执行上下文，其中包括Java虚拟机栈中引用的对象，比如方法参数、局部变量、临时变量等以及本地方法栈中引用的对象。</p><p>第三种为虚拟机内部的引用，如基本数据类型的Class对象，常驻的异常对象，系统类加载器、持有同步锁的对象等等。</p><p>而各个垃圾收集器，大多都遵行了”分代收集“的理论进行设计，在某些只针对部分区域进行垃圾收集的情况，也要考虑其余区域的对象引用了当前区域的对象的情况。针对于跨代引用的情况，垃圾收集器会在当前区域中建立记忆集的数据结构，来存放其余区域的跨代引用。记忆集是一种设计实现，目前最常见实现记忆集的方式为”卡表“的方式。</p><p>卡表最核心的思想就记忆集中存放的不是一个个具体的对象，而是一段段的内存区域，只要该区域中出现了跨代引用，那么就会把该段区域标记为脏区域。在垃圾收集中，会遍历所有脏区域，将脏区域中的对象加入GC Roots一并进行扫描。</p></blockquote><h2 id="如何将卡表中的区域标记为脏区域？"><a href="#如何将卡表中的区域标记为脏区域？" class="headerlink" title="如何将卡表中的区域标记为脏区域？"></a>如何将卡表中的区域标记为脏区域？</h2><blockquote><p>答：主要是通过写屏障实现的。</p><p>写屏障可以看作是虚拟机层面上对”引用类型字段赋值“这个动作的AOP切面，在引用对象赋值时会产生一个通知，供程序执行额外的动作。写屏障根据赋值的时机分为写前屏障和写后屏障，大多数垃圾收集器使用的都是写后屏障。</p><p>应用写屏障之后，虚拟机就会为所有的赋值操作生成响应的指令，这也会产生额外的开销。</p><p>除了写屏障的开销，卡表在高并发场景下还面临”伪共享“问题。</p></blockquote><h2 id="在可达性分析算法中，没有在引用链上的对象一定会被垃圾回收吗？"><a href="#在可达性分析算法中，没有在引用链上的对象一定会被垃圾回收吗？" class="headerlink" title="在可达性分析算法中，没有在引用链上的对象一定会被垃圾回收吗？"></a>在可达性分析算法中，没有在引用链上的对象一定会被垃圾回收吗？</h2><blockquote><p>答：不一定。</p><p>在垃圾回收算法中，一个对象被标记为“垃圾”，至少得需要经历两次标记。</p><p>第一次标记就是我们常说的可达性分析算法中的标记。</p><p>第二次标记针对的对象是第一次已经被标记的对象，JVM会对这些对象再次进行筛选，如果这些对象同时满足两个条件：</p><ol><li><p>对象覆盖了 finalize() 方法；</p></li><li><p>JVM没有执行过该对象的 finalize() 方法；</p></li></ol><p>那么，JVM就会在真正回收该对象之前的某个时间执行该对象的 finalize() 方法，如果对象的 finalize() 方法重新将自己与引用链上的某个对象建立了关联，那么JVM就不会将该对象进行垃圾回收。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot 对象</title>
      <link href="/2022/07/24/JVM/HotSpot%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/07/24/JVM/HotSpot%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>本章节涉及到的对象均是在 HotSpot 虚拟机的 Java 堆中。 </p><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>两种创建方式：</p><ol><li><p>如果内存布局是整齐的，那么只需要在以分配和未分配的内存分割点加一个指针，分配内存仅仅只需要将该指针往后移动需要分配对象的大小的位置即可。这种方式被称之为 <code>指针碰撞</code>；</p></li><li><p>如何内存布局是不整齐的，那么 JVM 必须维护一个列表，用来记录哪些内存块是可用。的，分配内存时，需要从列表中找到对应的内存块来分配。这种方式被称之为 <code>空闲列表</code>。</p></li></ol><p>内存布局是否整齐是由各个垃圾收集器采用的垃圾收集算法决定的。不过即使内存布局是不整齐的，也是可以通过预先分配一大块空闲内存块，然后在这块区域采用 <code>指针碰撞</code> 方式分配内存。</p><p>对象的内存分配在堆上，那么必然要考虑并发问题。两种方式解决：</p><ol><li><p>采用CAS+失败重拾来保证更新操作的原子性；</p></li><li><p>按照线程来分隔不同的空间，每个空间变成线程私有的，即每个线程在堆中预先分配一小块内存，这块内存称为 <code>本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）</code>，该选项可以通过 <code>-XX:+/-UseTLAB</code> 来设定。</p></li></ol><p>内存分配完之后，JVM需要堆对象头进行不要的设置，再之后就是执行构造函数，至此一个对象就已经创建完成。</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象的存储布局可以划分为三个部分：对象头、实例数据、对齐填充。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头分为两大部分数据：</p><ul><li><p>存储对象自身的运行时数据。如 HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等。</p></li><li><p>类型指针，及对象指向它的类型元数据的指针。（并不是所有虚拟机都有）</p></li></ul><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>对象真正存储的有效信息。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>HotSpot 虚拟机的自动内存管理要求对象起始地址必须是8字节的整数倍，也就是说所有对象的大小必须是8字节的整数倍，如果对象头+实例数据不满足要求，那么就要自动加上对齐填充。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java程序会通过栈上的 reference 数据来操作堆上的具体对象。reference 类型在 Java虚拟机规范中并没有定义这个引用应该通过什么方式去定位和访问，所以各个虚拟机有不同的实现，主流的访问方式有两种（HotSpot主要使用直接指针方式）：</p><ol><li><p>使用句柄池：移动对象时（垃圾收集非常常见动作）无需更改 reference 的指向，仅仅需要改变句柄池的指向。</p><img title="" src="file:///C:/Users/xieyi/AppData/Roaming/marktext/images/2022-07-24-17-13-17-image.png" alt="" data-align="inline"></li><li><p>使用直接指针：少了一次转发，速度更快。</p><img title="" src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpg" alt="" data-align="inline"></li></ol><p>    </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存区域</title>
      <link href="/2022/07/24/JVM/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2022/07/24/JVM/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><p>Java 内存区域的划分之所有网上有这么多不同的言论，主要是因为有两个原因：</p><ol><li><p>Java 版本不同；</p></li><li><p>虚拟机规范与实现上的不同。</p></li></ol><p>其中 Java 版本的不同导致的差异很好理解，而第二点主要要分清楚虚拟机规范和各个虚拟机实现，要明白 “公有设计、私有实现”的理念。即使我们绝大部分情况下接触都是 HotSpot 虚拟机，也不可将两者完全等同。</p><p>这里提到的内存区域都是运行时的内存区域，一个 Class 文件一定需要虚拟机的加载才能将对应数据存放到各个区域之间。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>当前线程所执行的字节码的行号指示器。是线程私有的。不会抛出 OOM 异常。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>虚拟机栈描述的是 Java 方法执行的线程内存模型。是线程私有的。每个方法被执行的时候，JVM会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法执行完毕后，该栈帧就会出栈。会抛出OOM异常和 StackOverflowError。</p><p>StackOverflowError: 线程请求的栈深度太深（e.g. 无限递归）；</p><p>OOM：栈扩展无法申请到内存，注意 HotSpot 虚拟机并不支持栈扩展。但是 HotSpot 虚拟机也有可能会抛出 OOM 异常，当程序无限创建新线程时，进程内存不够了就会出现OOM。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>存放这种编译器可知的各种基本数据结构、对象引用（可能是指针，也可能是句柄）、returnAddress类型。</p><p>局部变量表的存储空间以局部变量槽来表示，64位的long和double类型需要两个槽，其余只需要一个，虚拟机规范并没有指定槽的具体实现。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>作用和 Java 虚拟机栈类似，只不过服务的是本地方法（Native方法）。</p><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>堆管理着绝大部分对象实例和数组，是线程共享的。会抛出OOM异常。</p><p>虚拟机规范：所有的对象实例以及数组都应当在堆上分配。</p><p>HotSpot 实现：并不是完全遵循虚拟机规范，如栈上分配，标量替换。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>虚拟机规范：用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器变异后的缓存代码等数据。是线程共享的。会抛出OOM异常。</p><p>HotSpot 实现：</p><ul><li><p>jdk1.7 之前是用永久代实现的方法区，能够管理java堆一样管理这段内存，不用专门为方法区编写内存管理工作的代码；</p></li><li><p>jdk1.7 中，将字符串常量池、静态变量等移动到堆中；</p></li><li><p>jdk1.8 中，采用在本地内存中实现的元空间彻底代替永久代。</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区一部分。Class文件中的常量池表会存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放方法到方法区的运行时常量池中。</p><p>运行时常量池最重要的特性就是动态性，除了编译器产生的常量之外，运行期产生的常量（如String::intern）也会存放在运行时常量池。</p><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享，节省了内存空间。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>并不是java虚拟机规范中的定义的内存区域。主要是 jdk1.4 中新加入 NIO 类，引入了一种基于通道和缓冲区的I&#x2F;O方式，使用Native方法直接分配堆外内存。避免了在Java堆和Native对中来回复制数据。也会抛出OOM。</p><h1 id="面试真题（持续补充）"><a href="#面试真题（持续补充）" class="headerlink" title="面试真题（持续补充）"></a>面试真题（持续补充）</h1><h2 id="什么时候栈会出现OOM异常？"><a href="#什么时候栈会出现OOM异常？" class="headerlink" title="什么时候栈会出现OOM异常？"></a>什么时候栈会出现OOM异常？</h2><blockquote><p>答：如果是支持栈扩展的虚拟机实现，如远古时代的 Classic 虚拟机，如果程序中定义了大量的本地变量，导致此方法帧中本地变量表的查高难度很大，超过了虚拟机指定的栈容量（通过 -oss 指定），此时会出现OOM异常。</p><p>如果是不支持栈扩展的虚拟机实现，如 HotSpot 虚拟机实现，如果程序无限创建新线程并且线程一直不回收，由于单个进程内存是有上限的，最终会导致创建线程时无法申请到足够的内存，此时会出现OOM异常。</p></blockquote><h2 id="请详细说一下-Java-内存结构"><a href="#请详细说一下-Java-内存结构" class="headerlink" title="请详细说一下 Java 内存结构"></a>请详细说一下 Java 内存结构</h2><blockquote><p>答：Java 虚拟机规范中定义的 Java 内存结构可以分为程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。其中程序计数器、Java虚拟机栈、本地方法栈是线程私有的，Java堆、方法区是线程共享的。</p><p>程序计数器表示的是当前线程所执行的字节码的行号指示器。</p><p>Java虚拟机栈描述的是 Java 方法执行的线程内存模型。</p><p>本地方法栈描述的是 Native 方法执行的线程内存模型。</p><p>Java堆存放着绝大部分的对象实例和数组。</p><p>方法区存放的是被虚拟机加载的类型信息、常量、静态变量等信息。</p><p>除此之外，Java虚拟机规范中没有定义但是实际Java程序用到的内存区域叫堆外内存或者说直接内存，主要是 jdk1.4 引入的 NIO 类所使用。</p><p>需要注意的是，Java 虚拟机规范中定义的内存结构很有可能和我们常见的HotSpot虚拟机具体实现的内存结构有些差异。比如：在jdk1.7之前，HotSpot采用永久代实现方法区，而且jdk1.8时更改为了用元空间实现方法区。</p><p>另外，由于堆中是垃圾收集的主要场所，很多垃圾收集器会采用分代思想管理堆内存，但是这属于各个垃圾收集器自己的具体实现，而和 Java 虚拟机规范无关。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP笔记</title>
      <link href="/2022/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%A7%A3http/"/>
      <url>/2022/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%A7%A3http/</url>
      
        <content type="html"><![CDATA[<h2 id="《图解http》"><a href="#《图解http》" class="headerlink" title="《图解http》"></a>《图解http》</h2><h3 id="网络分层的好处"><a href="#网络分层的好处" class="headerlink" title="网络分层的好处"></a>网络分层的好处</h3><ol><li>不同层级之间的协议相互不影响</li><li>相同层级的协议之间的替换对其他层次无感</li><li>各层的协议设计更加简单</li></ol><h3 id="TCP-x2F-IP-四层协议架构和OSI七层协议架构的对比"><a href="#TCP-x2F-IP-四层协议架构和OSI七层协议架构的对比" class="headerlink" title="TCP&#x2F;IP 四层协议架构和OSI七层协议架构的对比"></a>TCP&#x2F;IP 四层协议架构和OSI七层协议架构的对比</h3><p>注：这里的硬件和网卡可以看做同一层,即数据链路层</p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/compare.png" width="600"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-|OSI推荐网络架构</span><br><span class="line">-|--| 应用层：应用相关的处理，比如说使用key/value的结构标明用户数据(username:damon)</span><br><span class="line">-|--| 表示层：数据加密，数据格式的约定(例如文本使用什么编码，音视频数据采用什么封装格式等)</span><br><span class="line">-|--| 回话层：按顺序进行传输，连接管理</span><br><span class="line">-|--| 传输层：收发的确认，专注于如何提高吞吐率，确认数据可达</span><br><span class="line">-|--| 网络层：确保通讯双方能够互相找到对方,寻址和路由选择</span><br><span class="line">-|--| 数据链路层：点对点的传输</span><br><span class="line">-|--| 物理层：比特流能够在物理媒介上进行传输,光或者电信号</span><br></pre></td></tr></table></figure><h3 id="HTTP设计原则"><a href="#HTTP设计原则" class="headerlink" title="HTTP设计原则"></a>HTTP设计原则</h3><ol><li>HTTP不保存状态<br>– 更加快速的处理大量事务<br>– 确保协议足够简洁，保证其可伸缩性</li><li>使用其他方式保证http请求在特定情况的响应速度<br>– 管线化(发出一个请求后，不需要等待请求响应就直接发送第二次请求)<br>– 长连接</li></ol><h3 id="HTTP的结构"><a href="#HTTP的结构" class="headerlink" title="HTTP的结构"></a>HTTP的结构</h3><p>用于HTTP协议交互的信息被称为HTTP报文，其结构通常为</p><ul><li>请求行：用于请求的方法，请求的URI和HTTP版本号(对什么—URI，做什么—请求的方法)</li><li>状态行：表明相应结果的状态码(404，500)，原因短语(NOT FOUND, SERVER ERROR)，和HTTP版本</li><li>首部字段(header)：包含请求和响应的各种条件和属性，一般有四种.header里面所包含的报文信息是HTTP协议里面的大头，大量的信息存放在header中</li><li>空行：用来分隔header和正文。因为header是可以用户自定义的，所以这里使用一个空行来说明所有的元数据都设置完毕</li></ul><h4 id="状态行中的状态码"><a href="#状态行中的状态码" class="headerlink" title="状态行中的状态码"></a>状态行中的状态码</h4><ul><li>1XX 表示请求正在处理</li><li>2XX 表示请求成功</li><li>3XX 表示请求重定向</li><li>4XX 表示客户端错误</li><li>5XX 表示服务端错误</li></ul><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><h5 id="header按照其实际用途分为一下四种"><a href="#header按照其实际用途分为一下四种" class="headerlink" title="header按照其实际用途分为一下四种"></a>header按照其实际用途分为一下四种</h5><ol><li><p>通用首部字段<br>也就是请求和响应都会使用这种header，代表为Cachache-Contro, Data， Via(代理服务器信息)等</p></li><li><p>请求首部字段&#x2F;请求头<br>客户端向服务端发送的请求的时候所使用头部，代表为 Host(请求资源所在服务器)， From(用户电邮), User-Agent等</p></li><li><p>响应首部字段&#x2F;响应头<br>补充了响应附加内容，也会要求客户端附加额外的内容信息，代表为Location(重定向至指定的URI), Proxy-Authenticate， Retry-after等</p></li><li><p>实体首部字段<br>针对请求&#x2F;响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息(及元数据).代表有Content-Type，Content-Language， Content-Encoding.</p></li></ol><h5 id="最常用的header之一：cookie"><a href="#最常用的header之一：cookie" class="headerlink" title="最常用的header之一：cookie"></a>最常用的header之一：cookie</h5><ul><li><p>为什么需要cookie？<br>因为http的设计就是无状态的，如果想要保存用户的个人信息，达到免登陆或者是记录上次浏览的地址等效果，则需要有一种方式能够保存当前用户的身份和状态信息，cookie就是解决这个问题的。虽然没有被编入标准化的http&#x2F;1.1中，但是在实际的web网站中，cookie得到广泛运用</p></li><li><p>cookie是怎么工作的<br>以n天内用户自动登录为例，当用户执行登录操作，提交表单，服务器在响应的头中就会添加上set-cookie，将被当前的状态信息保存下来并用sessionID作为标识。下一次用户发送http请求的时候，比如第二天，用户重新登录，发送的请求头中带有cookie:sessionID这样的字样时，服务端就能识别用户，达到自动登录的效果。(cookie的使用没有标准化，不同的web服务器可能使用可能实现不同。)</p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/cookie-usage.png" width="600"></li><li><p>其他的用户认证方式还有：Basic认证，Digest认证，SSL客户端认证，但是使用最为广泛的还是上面的这种表单认证。</p></li></ul><h4 id="HTTP的编码"><a href="#HTTP的编码" class="headerlink" title="HTTP的编码"></a>HTTP的编码</h4><ol><li>http可以编码(压缩)提升传输速率(gzip)</li><li>http的分块传输<br>– HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久连接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。<br>– 分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名<br>– 压缩时，分块传输编码可以用来分隔压缩对象的多个部分，虽然压缩是整体压缩，但是其压缩的输出使用文本描述的方案分块传输，这样可以一边压缩一边传输</li></ol><h4 id="http的其他特性"><a href="#http的其他特性" class="headerlink" title="http的其他特性"></a>http的其他特性</h4><ol><li><p>http发送多种类型的数据<br>使用MIME，比如如果使用的是表单类型，那么就使用(multipart&#x2F;from-data来表示这部分的数据类型)，使用boundary字符串来划分多部分对象集合，指明各类实体</p></li><li><p>http获取部分内容范围的请求<br>content-range:bytes 5001-10000&#x2F;10000 可以用在断点续传。</p></li><li><p>内容协商<br>中国的用户和美国的用户同时访问google，那么出来的页面是中文还是英文，也是可以通过http的内容协商来确定</p></li></ol><h4 id="与http协作的各类http服务器"><a href="#与http协作的各类http服务器" class="headerlink" title="与http协作的各类http服务器"></a>与http协作的各类http服务器</h4><ol><li>代理：可以是多级的，转发时，需要附加Via字符标记经过的主机信息<br>用途：可以作为缓存服务器，个人使用正向代理作为翻墙服务器使用。</li><li>网关：提高通信的安全性，屏蔽内部服务，可以作为一个集群的统一入口，提供统一的调用方式</li><li>隧道：按要求建立一条与服务器的通信线路，届时使用ssl等加密手段通信。</li></ol><h3 id="http协议的问题及缺点"><a href="#http协议的问题及缺点" class="headerlink" title="http协议的问题及缺点"></a>http协议的问题及缺点</h3><ol><li>通讯过程中使用明文，所有通讯内容可能被窃听<br>解法a. 使用ssl建立安全通道后，然后再这条线路上通讯。解法b.对http内容进行加密处理，但这需要通讯双方都知道加密规则</li><li>没有验证双方的身份，因此可能遭到伪装<br>客户端危害：不知道响应的是否为期望服务器<br>服务端危害：不知道客户端的身份，不知道响应数据是否真的发往了最开始发出请求的客户端，同时没有办法应对大量的恶意请求，如果知道客户端身份的话，可以设置响应频率。<br>解法a. 使用ssl验明身份。</li><li>没有办法验证受到的数据是否是期望数据，可能被篡改，可能被替换<br>确认数据是否完整和被篡改的方法常为hash值校验，而如使用md5进行校验，则网站上提供的md5结果本身，也可能被篡改。</li></ol><h3 id="解决http缺陷的答案，https"><a href="#解决http缺陷的答案，https" class="headerlink" title="解决http缺陷的答案，https"></a>解决http缺陷的答案，https</h3><p>https &#x3D; http+加密处理+认证+完整性保护.本质上https就是http+ssl,这里tls和ssl的关系是tls是在ssl的基础上开发的。</p><h4 id="加密处理"><a href="#加密处理" class="headerlink" title="加密处理"></a>加密处理</h4><ol><li>种类<br>现在的加密方法中，一般加密算法是公开的，但是加密所使用的秘钥是保密的。根据秘钥的使用方式不同分为对称加密和非对称加密。</li><li>对比<br>对称加密：加密时所使用的秘钥在通讯的双方都是相同的,这样的好处是加密所需要消耗的资源少，加密解密的效率高。但是一旦出现了秘钥泄露的情况，加密的意义也就不存在了，在互联网中不方便直接传输对称秘钥。<br>非对称加密：使用公私钥对数据进行加密和解密。其中公钥在互联网中传播，私钥只有自己本地存放。</li></ol><h4 id="https建立链接"><a href="#https建立链接" class="headerlink" title="https建立链接"></a>https建立链接</h4><p>服务端提供https服务及https通讯的大致流程如下<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/server_https.png" width="600"></p><p>客户端和服务器ssl建立连接的流程图如下所示<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/httpConnet.png" width="600"></p><h4 id="为何不将http全部替换成https"><a href="#为何不将http全部替换成https" class="headerlink" title="为何不将http全部替换成https"></a>为何不将http全部替换成https</h4><ol><li><p>https相较于http会慢2-100倍，这个慢体现在两个方面</p><ul><li>第一 ssl本身在建连接的时候(也就是握手)也是需要时间的。</li><li>第二 ssl在对内容进行加密和解密的时候需要消耗cpu，内存等资源，处理加密解密需要花费一定的时间。</li></ul></li><li><p>ssl所需要的证书本身也需要花钱。</p></li></ol><h4 id="基于http的功能追加协议"><a href="#基于http的功能追加协议" class="headerlink" title="基于http的功能追加协议"></a>基于http的功能追加协议</h4><p>当服务端经常会出现大量的更新时，期望客户端能够实时的获取更新后的内容，如果由客户端频繁去请求服务段，则造成大量的无意义请求。</p><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h5><p>利用js脚本和DOM，通过更新页面局部内容达到实时加载的效果。因为只需要更新局部内容，所以传输所带来的代价大大降低.但是依旧没有解决大量请求的问题。</p><h5 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h5><p>用户发送请求确认页面是否更新，comet先将请求挂起，一旦有可用的更新内容立即返回响应。但是为了保留响应，一次连接持续的时间也边长了。</p><h5 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h5><ul><li>多路复用：使用一个tcp连接就可以处理多个http请求</li><li>压缩http头部</li><li>推送功能：可以由服务端主动的向客户端发送数据，这样出现内容更新不需要被动等待</li><li>赋予请求优先级：</li><li>服务器提示功能：服务器可以主动提示客户端，请求所需的内容，这样如果客户端有缓存，避免不必要的请求</li></ul><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/spdy.png" width="600"><h5 id="http-x2F-1-1-队头阻塞问题"><a href="#http-x2F-1-1-队头阻塞问题" class="headerlink" title="http&#x2F;1.1 队头阻塞问题"></a>http&#x2F;1.1 队头阻塞问题</h5><ul><li>http&#x2F;1.1当中使用多路复用的情况</li></ul><ol><li>用户使用http请求访问获取<code>script.js</code>，各个网络传输协议会按下图添加各自内容<img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/hol_pic1.png" width="600"></li><li>用户此时又访问获取<code>style.css</code>网页内容，因为tcp是字节流，所以这里会将<code>style.css</code>响应的头放在上一个响应的末尾，响应的实际内容用新的tcp包存放<img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/hol_pic2.png" width="800"></li></ol><p>此时问题已经产生，加入<code>script.js</code>包很大，而<code>style.css</code>包很小，那么在接收到了pakcet3之后如果想要读取<code>style.css</code>里面的内容，必须要等到前面一个文件完全接受完毕才行（tcp保序）。即使后面的文件可能很小，但是http&#x2F;1.1没有方法能够获取这个信息.</p><h5 id="使用多路复用结局队头阻塞问题"><a href="#使用多路复用结局队头阻塞问题" class="headerlink" title="使用多路复用结局队头阻塞问题"></a>使用多路复用结局队头阻塞问题</h5><p>如果想要解决这个问题，就需要将大文件拆分成小的文件，然后交错的传输小的文件，如果以1表示第一个文件的包，2表示第二个文件的包则一个可能的例子就是原来为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111122</span><br></pre></td></tr></table></figure><p>现在改成(实际上多路复用发包的策略也是可以优化的，这里以轮询为例)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12121111111</span><br></pre></td></tr></table></figure><h5 id="http-x2F-1-1-无法使用多路复用"><a href="#http-x2F-1-1-无法使用多路复用" class="headerlink" title="http&#x2F;1.1 无法使用多路复用"></a>http&#x2F;1.1 无法使用多路复用</h5><p>当使用http1.1交错传输包时，传输js文件的首部部分，然后传输css文件的首部和第一个包，在传输第三个文件的包时，由于这里第三个文件的包里面既包含了js的数据，又包含了css文件的数据（下图三）。当http解析的时候，由于所有的数据都是纯粹的文本，所以当发送第二个包的时候，http会将第二个包中的所有数据视作第一个包也就是js文件中的剩余部分，并且在读到第1000个字节的时候停下来。在读取第三个包的时候，由于他不符合http头的格式，所以http模块也只能将第三个包丢弃，最终js的一个可能的解释结果如下图图四<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/http_multy.png" width="600"><br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/js_parser_result.png" width="600"></p><p>ps:有些场景（访问多个页面）可以使用多个tcp连接来防止多路复用导致的head of line blocking</p><h4 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h4><p>http2.前的技术所开发的新的http的规范，大量参考了SPDY里面的内容</p><h5 id="http2-0里面的多路复用"><a href="#http2-0里面的多路复用" class="headerlink" title="http2.0里面的多路复用"></a>http2.0里面的多路复用</h5><p>http1.1之所以没有办法使用多路复用的关键问题在于没有办法区分数据从哪一部分到哪一部分是属于那个http请求的，从图里可以清楚的看到，http2.0加上了一些简单的控制信息(数据帧&#x2F;data frame)，即<code>stream id</code>，同时在数据域前面加上了<code>content-length</code>和其<code>stream id</code><br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/http2_multy.png" width="600"></p><p>此时http2.0已经能够交互式的拿到数据帧并且不会出现队头阻塞问题，但是还有一个问题是需要注意的，那就是数据的传输顺序对于整体web交互的性能会产生非常的大的影响。</p><ul><li>Fair multiplexing (for example two progressive JPEGs): 12121212</li><li>Weighted multiplexing (2 is twice as important as 1): 221221221</li><li>Reversed sequential scheduling (for example 2 is a key Server Pushed resource): 22221111</li><li>Partial scheduling (stream 1 is aborted and not sent in full): 112222</li></ul><h5 id="http2-0的多路复用只是解决了应用层的队头阻塞"><a href="#http2-0的多路复用只是解决了应用层的队头阻塞" class="headerlink" title="http2.0的多路复用只是解决了应用层的队头阻塞"></a>http2.0的多路复用只是解决了应用层的队头阻塞</h5><p>首先明确一点，tcp并不知道他传输的数据的使用的是什么应用层协议。在下面这个图当中，如果tcp包1和tcp包3到达，但是此时tcp包2尚未到达&#x2F;丢包待重传，从http的角度来看，实际上此时streamId1的数据已经全部送达，但是从tcp的角度来看，由于tcp包2没有送达，所以tcp包3就会存在于缓冲区，等待tcp包2的到来，然后上传给应用程序。<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/tcp_hol.png" width="800"></p><p>ps:虽然http2.0没有解决tcp层面的队头阻塞问题，但是网络数据丢包的情况是相对少见的，从影响上来看，远不及http队头阻塞造成的影响大。</p><h4 id="总结http2-0中的改进"><a href="#总结http2-0中的改进" class="headerlink" title="总结http2.0中的改进"></a>总结http2.0中的改进</h4><ol><li>多路复用(multiplexing)：即上文描述的解决队头问题后使用一个连接同时处理多个请求(HTTP&#x2F;2 does this by splitting data into binary-code messages and numbering these messages so that the client knows which stream each binary message belongs to.)</li><li>服务推送(server push)：以抖音或者是直播为例，每秒都有大量的新数据上传，替换传统的客户端请求更改为服务端主动推送会逐渐增大应用场景。</li><li>头部压缩(header compression)：http&#x2F;2使用了HPACK算法进行压缩，减少了重复信息的发送。(This eliminates&#x2F;消除 a few bytes from every HTTP packet. Given the volume of HTTP packets involved in loading even a single webpage, those bytes add up quickly, resulting in faster loading.)</li></ol><p>ps: 这里的多路复用就包含了二进制分帧，实际上多路复用就是需要将数据以而二进制的形式封装到他的需要传输的包里面</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/">Head-of-Line Blocking in QUIC and HTTP&#x2F;3: The Details</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/performance/http2-vs-http1.1/">What are the other differences between HTTP&#x2F;2 and HTTP&#x2F;1.1 that impact performance?</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
