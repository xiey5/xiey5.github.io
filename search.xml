<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HotSpot 对象</title>
      <link href="/2022/07/24/JVM/HotSpot%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/07/24/JVM/HotSpot%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>本章节涉及到的对象均是在 HotSpot 虚拟机的 Java 堆中。 </p><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>两种创建方式：</p><ol><li><p>如果内存布局是整齐的，那么只需要在以分配和未分配的内存分割点加一个指针，分配内存仅仅只需要将该指针往后移动需要分配对象的大小的位置即可。这种方式被称之为 <code>指针碰撞</code>；</p></li><li><p>如何内存布局是不整齐的，那么 JVM 必须维护一个列表，用来记录哪些内存块是可用。的，分配内存时，需要从列表中找到对应的内存块来分配。这种方式被称之为 <code>空闲列表</code>。</p></li></ol><p>内存布局是否整齐是由各个垃圾收集器采用的垃圾收集算法决定的。不过即使内存布局是不整齐的，也是可以通过预先分配一大块空闲内存块，然后在这块区域采用 <code>指针碰撞</code> 方式分配内存。</p><p>对象的内存分配在堆上，那么必然要考虑并发问题。两种方式解决：</p><ol><li><p>采用CAS+失败重拾来保证更新操作的原子性；</p></li><li><p>按照线程来分隔不同的空间，每个空间变成线程私有的，即每个线程在堆中预先分配一小块内存，这块内存称为 <code>本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）</code>，该选项可以通过 <code>-XX:+/-UseTLAB</code> 来设定。</p></li></ol><p>内存分配完之后，JVM需要堆对象头进行不要的设置，再之后就是执行构造函数，至此一个对象就已经创建完成。</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象的存储布局可以划分为三个部分：对象头、实例数据、对齐填充。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头分为两大部分数据：</p><ul><li><p>存储对象自身的运行时数据。如 HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等。</p></li><li><p>类型指针，及对象指向它的类型元数据的指针。（并不是所有虚拟机都有）</p></li></ul><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>对象真正存储的有效信息。</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>HotSpot 虚拟机的自动内存管理要求对象起始地址必须是8字节的整数倍，也就是说所有对象的大小必须是8字节的整数倍，如果对象头+实例数据不满足要求，那么就要自动加上对齐填充。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java程序会通过栈上的 reference 数据来操作堆上的具体对象。reference 类型在 Java虚拟机规范中并没有定义这个引用应该通过什么方式去定位和访问，所以各个虚拟机有不同的实现，主流的访问方式有两种（HotSpot主要使用直接指针方式）：</p><ol><li><p>使用句柄池：移动对象时（垃圾收集非常常见动作）无需更改 reference 的指向，仅仅需要改变句柄池的指向。</p><img title="" src="file:///C:/Users/xieyi/AppData/Roaming/marktext/images/2022-07-24-17-13-17-image.png" alt="" data-align="inline"></li><li><p>使用直接指针：少了一次转发，速度更快。</p><img title="" src="https://raw.githubusercontent.com/xiey5/hexo-image/main/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpg" alt="" data-align="inline"></li></ol><p>    </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存区域</title>
      <link href="/2022/07/24/JVM/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2022/07/24/JVM/Java%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><p>Java 内存区域的划分之所有网上有这么多不同的言论，主要是因为有两个原因：</p><ol><li><p>Java 版本不同；</p></li><li><p>虚拟机规范与实现上的不同。</p></li></ol><p>其中 Java 版本的不同导致的差异很好理解，而第二点主要要分清楚虚拟机规范和各个虚拟机实现，要明白 “公有设计、私有实现”的理念。即使我们绝大部分情况下接触都是 HotSpot 虚拟机，也不可将两者完全等同。</p><p>这里提到的内存区域都是运行时的内存区域，一个 Class 文件一定需要虚拟机的加载才能将对应数据存放到各个区域之间。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>当前线程所执行的字节码的行号指示器。是线程私有的。不会抛出 OOM 异常。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>虚拟机栈描述的是 Java 方法执行的线程内存模型。是线程私有的。每个方法被执行的时候，JVM会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法执行完毕后，该栈帧就会出栈。会抛出OOM异常和 StackOverflowError。</p><p>StackOverflowError: 线程请求的栈深度太深（e.g. 无限递归）；</p><p>OOM：栈扩展无法申请到内存，注意 HotSpot 虚拟机并不支持栈扩展。但是 HotSpot 虚拟机也有可能会抛出 OOM 异常，当程序无限创建新线程时，进程内存不够了就会出现OOM。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>存放这种编译器可知的各种基本数据结构、对象引用（可能是指针，也可能是句柄）、returnAddress类型。</p><p>局部变量表的存储空间以局部变量槽来表示，64位的long和double类型需要两个槽，其余只需要一个，虚拟机规范并没有指定槽的具体实现。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>作用和 Java 虚拟机栈类似，只不过服务的是本地方法（Native方法）。</p><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>堆管理着绝大部分对象实例和数组，是线程共享的。会抛出OOM异常。</p><p>虚拟机规范：所有的对象实例以及数组都应当在堆上分配。</p><p>HotSpot 实现：并不是完全遵循虚拟机规范，如栈上分配，标量替换。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>虚拟机规范：用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器变异后的缓存代码等数据。是线程共享的。会抛出OOM异常。</p><p>HotSpot 实现：</p><ul><li><p>jdk1.7 之前是用永久代实现的方法区，能够管理java堆一样管理这段内存，不用专门为方法区编写内存管理工作的代码；</p></li><li><p>jdk1.7 中，将字符串常量池、静态变量等移动到堆中；</p></li><li><p>jdk1.8 中，采用在本地内存中实现的元空间彻底代替永久代。</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区一部分。Class文件中的常量池表会存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放方法到方法区的运行时常量池中。</p><p>运行时常量池最重要的特性就是动态性，除了编译器产生的常量之外，运行期产生的常量（如String::intern）也会存放在运行时常量池。</p><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享，节省了内存空间。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>并不是java虚拟机规范中的定义的内存区域。主要是 jdk1.4 中新加入 NIO 类，引入了一种基于通道和缓冲区的I&#x2F;O方式，使用Native方法直接分配堆外内存。避免了在Java堆和Native对中来回复制数据。也会抛出OOM。</p><h1 id="面试真题（持续补充）"><a href="#面试真题（持续补充）" class="headerlink" title="面试真题（持续补充）"></a>面试真题（持续补充）</h1><h2 id="什么时候栈会出现OOM异常？"><a href="#什么时候栈会出现OOM异常？" class="headerlink" title="什么时候栈会出现OOM异常？"></a>什么时候栈会出现OOM异常？</h2><blockquote><p>答：如果是支持栈扩展的虚拟机实现，如远古时代的 Classic 虚拟机，如果程序中定义了大量的本地变量，导致此方法帧中本地变量表的查高难度很大，超过了虚拟机指定的栈容量（通过 -oss 指定），此时会出现OOM异常。</p><p>如果是不支持栈扩展的虚拟机实现，如 HotSpot 虚拟机实现，如果程序无限创建新线程并且线程一直不回收，由于单个进程内存是有上限的，最终会导致创建线程时无法申请到足够的内存，此时会出现OOM异常。</p></blockquote><h2 id="请详细说一下-Java-内存结构"><a href="#请详细说一下-Java-内存结构" class="headerlink" title="请详细说一下 Java 内存结构"></a>请详细说一下 Java 内存结构</h2><blockquote><p>答：Java 虚拟机规范中定义的 Java 内存结构可以分为程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。其中程序计数器、Java虚拟机栈、本地方法栈是线程私有的，Java堆、方法区是线程共享的。</p><p>程序计数器表示的是当前线程所执行的字节码的行号指示器。</p><p>Java虚拟机栈描述的是 Java 方法执行的线程内存模型。</p><p>本地方法栈描述的是 Native 方法执行的线程内存模型。</p><p>Java堆存放着绝大部分的对象实例和数组。</p><p>方法区存放的是被虚拟机加载的类型信息、常量、静态变量等信息。</p><p>除此之外，Java虚拟机规范中没有定义但是实际Java程序用到的内存区域叫堆外内存或者说直接内存，主要是 jdk1.4 引入的 NIO 类所使用。</p><p>需要注意的是，Java 虚拟机规范中定义的内存结构很有可能和我们常见的HotSpot虚拟机具体实现的内存结构有些差异。比如：在jdk1.7之前，HotSpot采用永久代实现方法区，而且jdk1.8时更改为了用元空间实现方法区。</p><p>另外，由于堆中是垃圾收集的主要场所，很多垃圾收集器会采用分代思想管理堆内存，但是这属于各个垃圾收集器自己的具体实现，而和 Java 虚拟机规范无关。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JVM </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP笔记</title>
      <link href="/2022/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%A7%A3http/"/>
      <url>/2022/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%9B%BE%E8%A7%A3http/</url>
      
        <content type="html"><![CDATA[<h2 id="《图解http》"><a href="#《图解http》" class="headerlink" title="《图解http》"></a>《图解http》</h2><h3 id="网络分层的好处"><a href="#网络分层的好处" class="headerlink" title="网络分层的好处"></a>网络分层的好处</h3><ol><li>不同层级之间的协议相互不影响</li><li>相同层级的协议之间的替换对其他层次无感</li><li>各层的协议设计更加简单</li></ol><h3 id="TCP-x2F-IP-四层协议架构和OSI七层协议架构的对比"><a href="#TCP-x2F-IP-四层协议架构和OSI七层协议架构的对比" class="headerlink" title="TCP&#x2F;IP 四层协议架构和OSI七层协议架构的对比"></a>TCP&#x2F;IP 四层协议架构和OSI七层协议架构的对比</h3><p>注：这里的硬件和网卡可以看做同一层,即数据链路层</p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/compare.png" width="600"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-|OSI推荐网络架构</span><br><span class="line">-|--| 应用层：应用相关的处理，比如说使用key/value的结构标明用户数据(username:damon)</span><br><span class="line">-|--| 表示层：数据加密，数据格式的约定(例如文本使用什么编码，音视频数据采用什么封装格式等)</span><br><span class="line">-|--| 回话层：按顺序进行传输，连接管理</span><br><span class="line">-|--| 传输层：收发的确认，专注于如何提高吞吐率，确认数据可达</span><br><span class="line">-|--| 网络层：确保通讯双方能够互相找到对方,寻址和路由选择</span><br><span class="line">-|--| 数据链路层：点对点的传输</span><br><span class="line">-|--| 物理层：比特流能够在物理媒介上进行传输,光或者电信号</span><br></pre></td></tr></table></figure><h3 id="HTTP设计原则"><a href="#HTTP设计原则" class="headerlink" title="HTTP设计原则"></a>HTTP设计原则</h3><ol><li>HTTP不保存状态<br>– 更加快速的处理大量事务<br>– 确保协议足够简洁，保证其可伸缩性</li><li>使用其他方式保证http请求在特定情况的响应速度<br>– 管线化(发出一个请求后，不需要等待请求响应就直接发送第二次请求)<br>– 长连接</li></ol><h3 id="HTTP的结构"><a href="#HTTP的结构" class="headerlink" title="HTTP的结构"></a>HTTP的结构</h3><p>用于HTTP协议交互的信息被称为HTTP报文，其结构通常为</p><ul><li>请求行：用于请求的方法，请求的URI和HTTP版本号(对什么—URI，做什么—请求的方法)</li><li>状态行：表明相应结果的状态码(404，500)，原因短语(NOT FOUND, SERVER ERROR)，和HTTP版本</li><li>首部字段(header)：包含请求和响应的各种条件和属性，一般有四种.header里面所包含的报文信息是HTTP协议里面的大头，大量的信息存放在header中</li><li>空行：用来分隔header和正文。因为header是可以用户自定义的，所以这里使用一个空行来说明所有的元数据都设置完毕</li></ul><h4 id="状态行中的状态码"><a href="#状态行中的状态码" class="headerlink" title="状态行中的状态码"></a>状态行中的状态码</h4><ul><li>1XX 表示请求正在处理</li><li>2XX 表示请求成功</li><li>3XX 表示请求重定向</li><li>4XX 表示客户端错误</li><li>5XX 表示服务端错误</li></ul><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><h5 id="header按照其实际用途分为一下四种"><a href="#header按照其实际用途分为一下四种" class="headerlink" title="header按照其实际用途分为一下四种"></a>header按照其实际用途分为一下四种</h5><ol><li><p>通用首部字段<br>也就是请求和响应都会使用这种header，代表为Cachache-Contro, Data， Via(代理服务器信息)等</p></li><li><p>请求首部字段&#x2F;请求头<br>客户端向服务端发送的请求的时候所使用头部，代表为 Host(请求资源所在服务器)， From(用户电邮), User-Agent等</p></li><li><p>响应首部字段&#x2F;响应头<br>补充了响应附加内容，也会要求客户端附加额外的内容信息，代表为Location(重定向至指定的URI), Proxy-Authenticate， Retry-after等</p></li><li><p>实体首部字段<br>针对请求&#x2F;响应报文的实体部分使用的首部，补充了资源内容更新时间等与实体有关的信息(及元数据).代表有Content-Type，Content-Language， Content-Encoding.</p></li></ol><h5 id="最常用的header之一：cookie"><a href="#最常用的header之一：cookie" class="headerlink" title="最常用的header之一：cookie"></a>最常用的header之一：cookie</h5><ul><li><p>为什么需要cookie？<br>因为http的设计就是无状态的，如果想要保存用户的个人信息，达到免登陆或者是记录上次浏览的地址等效果，则需要有一种方式能够保存当前用户的身份和状态信息，cookie就是解决这个问题的。虽然没有被编入标准化的http&#x2F;1.1中，但是在实际的web网站中，cookie得到广泛运用</p></li><li><p>cookie是怎么工作的<br>以n天内用户自动登录为例，当用户执行登录操作，提交表单，服务器在响应的头中就会添加上set-cookie，将被当前的状态信息保存下来并用sessionID作为标识。下一次用户发送http请求的时候，比如第二天，用户重新登录，发送的请求头中带有cookie:sessionID这样的字样时，服务端就能识别用户，达到自动登录的效果。(cookie的使用没有标准化，不同的web服务器可能使用可能实现不同。)</p><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/cookie-usage.png" width="600"></li><li><p>其他的用户认证方式还有：Basic认证，Digest认证，SSL客户端认证，但是使用最为广泛的还是上面的这种表单认证。</p></li></ul><h4 id="HTTP的编码"><a href="#HTTP的编码" class="headerlink" title="HTTP的编码"></a>HTTP的编码</h4><ol><li>http可以编码(压缩)提升传输速率(gzip)</li><li>http的分块传输<br>– HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久连接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。<br>– 分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名<br>– 压缩时，分块传输编码可以用来分隔压缩对象的多个部分，虽然压缩是整体压缩，但是其压缩的输出使用文本描述的方案分块传输，这样可以一边压缩一边传输</li></ol><h4 id="http的其他特性"><a href="#http的其他特性" class="headerlink" title="http的其他特性"></a>http的其他特性</h4><ol><li><p>http发送多种类型的数据<br>使用MIME，比如如果使用的是表单类型，那么就使用(multipart&#x2F;from-data来表示这部分的数据类型)，使用boundary字符串来划分多部分对象集合，指明各类实体</p></li><li><p>http获取部分内容范围的请求<br>content-range:bytes 5001-10000&#x2F;10000 可以用在断点续传。</p></li><li><p>内容协商<br>中国的用户和美国的用户同时访问google，那么出来的页面是中文还是英文，也是可以通过http的内容协商来确定</p></li></ol><h4 id="与http协作的各类http服务器"><a href="#与http协作的各类http服务器" class="headerlink" title="与http协作的各类http服务器"></a>与http协作的各类http服务器</h4><ol><li>代理：可以是多级的，转发时，需要附加Via字符标记经过的主机信息<br>用途：可以作为缓存服务器，个人使用正向代理作为翻墙服务器使用。</li><li>网关：提高通信的安全性，屏蔽内部服务，可以作为一个集群的统一入口，提供统一的调用方式</li><li>隧道：按要求建立一条与服务器的通信线路，届时使用ssl等加密手段通信。</li></ol><h3 id="http协议的问题及缺点"><a href="#http协议的问题及缺点" class="headerlink" title="http协议的问题及缺点"></a>http协议的问题及缺点</h3><ol><li>通讯过程中使用明文，所有通讯内容可能被窃听<br>解法a. 使用ssl建立安全通道后，然后再这条线路上通讯。解法b.对http内容进行加密处理，但这需要通讯双方都知道加密规则</li><li>没有验证双方的身份，因此可能遭到伪装<br>客户端危害：不知道响应的是否为期望服务器<br>服务端危害：不知道客户端的身份，不知道响应数据是否真的发往了最开始发出请求的客户端，同时没有办法应对大量的恶意请求，如果知道客户端身份的话，可以设置响应频率。<br>解法a. 使用ssl验明身份。</li><li>没有办法验证受到的数据是否是期望数据，可能被篡改，可能被替换<br>确认数据是否完整和被篡改的方法常为hash值校验，而如使用md5进行校验，则网站上提供的md5结果本身，也可能被篡改。</li></ol><h3 id="解决http缺陷的答案，https"><a href="#解决http缺陷的答案，https" class="headerlink" title="解决http缺陷的答案，https"></a>解决http缺陷的答案，https</h3><p>https &#x3D; http+加密处理+认证+完整性保护.本质上https就是http+ssl,这里tls和ssl的关系是tls是在ssl的基础上开发的。</p><h4 id="加密处理"><a href="#加密处理" class="headerlink" title="加密处理"></a>加密处理</h4><ol><li>种类<br>现在的加密方法中，一般加密算法是公开的，但是加密所使用的秘钥是保密的。根据秘钥的使用方式不同分为对称加密和非对称加密。</li><li>对比<br>对称加密：加密时所使用的秘钥在通讯的双方都是相同的,这样的好处是加密所需要消耗的资源少，加密解密的效率高。但是一旦出现了秘钥泄露的情况，加密的意义也就不存在了，在互联网中不方便直接传输对称秘钥。<br>非对称加密：使用公私钥对数据进行加密和解密。其中公钥在互联网中传播，私钥只有自己本地存放。</li></ol><h4 id="https建立链接"><a href="#https建立链接" class="headerlink" title="https建立链接"></a>https建立链接</h4><p>服务端提供https服务及https通讯的大致流程如下<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/server_https.png" width="600"></p><p>客户端和服务器ssl建立连接的流程图如下所示<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/httpConnet.png" width="600"></p><h4 id="为何不将http全部替换成https"><a href="#为何不将http全部替换成https" class="headerlink" title="为何不将http全部替换成https"></a>为何不将http全部替换成https</h4><ol><li><p>https相较于http会慢2-100倍，这个慢体现在两个方面</p><ul><li>第一 ssl本身在建连接的时候(也就是握手)也是需要时间的。</li><li>第二 ssl在对内容进行加密和解密的时候需要消耗cpu，内存等资源，处理加密解密需要花费一定的时间。</li></ul></li><li><p>ssl所需要的证书本身也需要花钱。</p></li></ol><h4 id="基于http的功能追加协议"><a href="#基于http的功能追加协议" class="headerlink" title="基于http的功能追加协议"></a>基于http的功能追加协议</h4><p>当服务端经常会出现大量的更新时，期望客户端能够实时的获取更新后的内容，如果由客户端频繁去请求服务段，则造成大量的无意义请求。</p><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h5><p>利用js脚本和DOM，通过更新页面局部内容达到实时加载的效果。因为只需要更新局部内容，所以传输所带来的代价大大降低.但是依旧没有解决大量请求的问题。</p><h5 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h5><p>用户发送请求确认页面是否更新，comet先将请求挂起，一旦有可用的更新内容立即返回响应。但是为了保留响应，一次连接持续的时间也边长了。</p><h5 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h5><ul><li>多路复用：使用一个tcp连接就可以处理多个http请求</li><li>压缩http头部</li><li>推送功能：可以由服务端主动的向客户端发送数据，这样出现内容更新不需要被动等待</li><li>赋予请求优先级：</li><li>服务器提示功能：服务器可以主动提示客户端，请求所需的内容，这样如果客户端有缓存，避免不必要的请求</li></ul><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/spdy.png" width="600"><h5 id="http-x2F-1-1-队头阻塞问题"><a href="#http-x2F-1-1-队头阻塞问题" class="headerlink" title="http&#x2F;1.1 队头阻塞问题"></a>http&#x2F;1.1 队头阻塞问题</h5><ul><li>http&#x2F;1.1当中使用多路复用的情况</li></ul><ol><li>用户使用http请求访问获取<code>script.js</code>，各个网络传输协议会按下图添加各自内容<img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/hol_pic1.png" width="600"></li><li>用户此时又访问获取<code>style.css</code>网页内容，因为tcp是字节流，所以这里会将<code>style.css</code>响应的头放在上一个响应的末尾，响应的实际内容用新的tcp包存放<img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/hol_pic2.png" width="800"></li></ol><p>此时问题已经产生，加入<code>script.js</code>包很大，而<code>style.css</code>包很小，那么在接收到了pakcet3之后如果想要读取<code>style.css</code>里面的内容，必须要等到前面一个文件完全接受完毕才行（tcp保序）。即使后面的文件可能很小，但是http&#x2F;1.1没有方法能够获取这个信息.</p><h5 id="使用多路复用结局队头阻塞问题"><a href="#使用多路复用结局队头阻塞问题" class="headerlink" title="使用多路复用结局队头阻塞问题"></a>使用多路复用结局队头阻塞问题</h5><p>如果想要解决这个问题，就需要将大文件拆分成小的文件，然后交错的传输小的文件，如果以1表示第一个文件的包，2表示第二个文件的包则一个可能的例子就是原来为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111122</span><br></pre></td></tr></table></figure><p>现在改成(实际上多路复用发包的策略也是可以优化的，这里以轮询为例)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12121111111</span><br></pre></td></tr></table></figure><h5 id="http-x2F-1-1-无法使用多路复用"><a href="#http-x2F-1-1-无法使用多路复用" class="headerlink" title="http&#x2F;1.1 无法使用多路复用"></a>http&#x2F;1.1 无法使用多路复用</h5><p>当使用http1.1交错传输包时，传输js文件的首部部分，然后传输css文件的首部和第一个包，在传输第三个文件的包时，由于这里第三个文件的包里面既包含了js的数据，又包含了css文件的数据（下图三）。当http解析的时候，由于所有的数据都是纯粹的文本，所以当发送第二个包的时候，http会将第二个包中的所有数据视作第一个包也就是js文件中的剩余部分，并且在读到第1000个字节的时候停下来。在读取第三个包的时候，由于他不符合http头的格式，所以http模块也只能将第三个包丢弃，最终js的一个可能的解释结果如下图图四<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/http_multy.png" width="600"><br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/js_parser_result.png" width="600"></p><p>ps:有些场景（访问多个页面）可以使用多个tcp连接来防止多路复用导致的head of line blocking</p><h4 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h4><p>http2.前的技术所开发的新的http的规范，大量参考了SPDY里面的内容</p><h5 id="http2-0里面的多路复用"><a href="#http2-0里面的多路复用" class="headerlink" title="http2.0里面的多路复用"></a>http2.0里面的多路复用</h5><p>http1.1之所以没有办法使用多路复用的关键问题在于没有办法区分数据从哪一部分到哪一部分是属于那个http请求的，从图里可以清楚的看到，http2.0加上了一些简单的控制信息(数据帧&#x2F;data frame)，即<code>stream id</code>，同时在数据域前面加上了<code>content-length</code>和其<code>stream id</code><br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/http2_multy.png" width="600"></p><p>此时http2.0已经能够交互式的拿到数据帧并且不会出现队头阻塞问题，但是还有一个问题是需要注意的，那就是数据的传输顺序对于整体web交互的性能会产生非常的大的影响。</p><ul><li>Fair multiplexing (for example two progressive JPEGs): 12121212</li><li>Weighted multiplexing (2 is twice as important as 1): 221221221</li><li>Reversed sequential scheduling (for example 2 is a key Server Pushed resource): 22221111</li><li>Partial scheduling (stream 1 is aborted and not sent in full): 112222</li></ul><h5 id="http2-0的多路复用只是解决了应用层的队头阻塞"><a href="#http2-0的多路复用只是解决了应用层的队头阻塞" class="headerlink" title="http2.0的多路复用只是解决了应用层的队头阻塞"></a>http2.0的多路复用只是解决了应用层的队头阻塞</h5><p>首先明确一点，tcp并不知道他传输的数据的使用的是什么应用层协议。在下面这个图当中，如果tcp包1和tcp包3到达，但是此时tcp包2尚未到达&#x2F;丢包待重传，从http的角度来看，实际上此时streamId1的数据已经全部送达，但是从tcp的角度来看，由于tcp包2没有送达，所以tcp包3就会存在于缓冲区，等待tcp包2的到来，然后上传给应用程序。<br><img src="https://raw.githubusercontent.com/xiey5/hexo-image/main/tcp_hol.png" width="800"></p><p>ps:虽然http2.0没有解决tcp层面的队头阻塞问题，但是网络数据丢包的情况是相对少见的，从影响上来看，远不及http队头阻塞造成的影响大。</p><h4 id="总结http2-0中的改进"><a href="#总结http2-0中的改进" class="headerlink" title="总结http2.0中的改进"></a>总结http2.0中的改进</h4><ol><li>多路复用(multiplexing)：即上文描述的解决队头问题后使用一个连接同时处理多个请求(HTTP&#x2F;2 does this by splitting data into binary-code messages and numbering these messages so that the client knows which stream each binary message belongs to.)</li><li>服务推送(server push)：以抖音或者是直播为例，每秒都有大量的新数据上传，替换传统的客户端请求更改为服务端主动推送会逐渐增大应用场景。</li><li>头部压缩(header compression)：http&#x2F;2使用了HPACK算法进行压缩，减少了重复信息的发送。(This eliminates&#x2F;消除 a few bytes from every HTTP packet. Given the volume of HTTP packets involved in loading even a single webpage, those bytes add up quickly, resulting in faster loading.)</li></ol><p>ps: 这里的多路复用就包含了二进制分帧，实际上多路复用就是需要将数据以而二进制的形式封装到他的需要传输的包里面</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/">Head-of-Line Blocking in QUIC and HTTP&#x2F;3: The Details</a></p><p><a href="https://www.cloudflare.com/zh-cn/learning/performance/http2-vs-http1.1/">What are the other differences between HTTP&#x2F;2 and HTTP&#x2F;1.1 that impact performance?</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 网络 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/23/hello-world/"/>
      <url>/2022/07/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
